{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Watchdog from './watchdog.js';\nimport EditorWatchdog from './editorwatchdog.js';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties.js';\nimport getSubNodes from './utils/getsubnodes.js';\nconst mainQueueId = Symbol('MainQueueId');\n/**\n * A watchdog for the {@link module:core/context~Context} class.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class ContextWatchdog extends Watchdog {\n  /**\n   * The context watchdog class constructor.\n   *\n   * ```ts\n   * const watchdog = new ContextWatchdog( Context );\n   *\n   * await watchdog.create( contextConfiguration );\n   *\n   * await watchdog.add( item );\n   * ```\n   *\n   * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\n   *\n   * @param Context The {@link module:core/context~Context} class.\n   * @param watchdogConfig The watchdog configuration.\n   */\n  constructor(Context, watchdogConfig = {}) {\n    super(watchdogConfig);\n    /**\n     * A map of internal watchdogs for added items.\n     */\n    this._watchdogs = new Map();\n    /**\n     * The current context instance.\n     */\n    this._context = null;\n    /**\n     * Context properties (nodes/references) that are gathered during the initial context creation\n     * and are used to distinguish the origin of an error.\n     */\n    this._contextProps = new Set();\n    /**\n     * An action queue, which is used to handle async functions queuing.\n     */\n    this._actionQueues = new ActionQueues();\n    this._watchdogConfig = watchdogConfig;\n    // Default creator and destructor.\n    this._creator = contextConfig => Context.create(contextConfig);\n    this._destructor = context => context.destroy();\n    this._actionQueues.onEmpty(() => {\n      if (this.state === 'initializing') {\n        this.state = 'ready';\n        this._fire('stateChange');\n      }\n    });\n  }\n  /**\n   * Sets the function that is responsible for the context creation.\n   * It expects a function that should return a promise (or `undefined`).\n   *\n   * ```ts\n   * watchdog.setCreator( config => Context.create( config ) );\n   * ```\n   */\n  setCreator(creator) {\n    this._creator = creator;\n  }\n  /**\n   * Sets the function that is responsible for the context destruction.\n   * Overrides the default destruction function, which destroys only the context instance.\n   * It expects a function that should return a promise (or `undefined`).\n   *\n   * ```ts\n   * watchdog.setDestructor( context => {\n   * \t// Do something before the context is destroyed.\n   *\n   * \treturn context\n   * \t\t.destroy()\n   * \t\t.then( () => {\n   * \t\t\t// Do something after the context is destroyed.\n   * \t\t} );\n   * } );\n   * ```\n   */\n  setDestructor(destructor) {\n    this._destructor = destructor;\n  }\n  /**\n   * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\n   * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\n   */\n  get context() {\n    return this._context;\n  }\n  /**\n   * Initializes the context watchdog. Once it is created, the watchdog takes care about\n   * recreating the context and the provided items, and starts the error handling mechanism.\n   *\n   * ```ts\n   * await watchdog.create( {\n   * \tplugins: []\n   * } );\n   * ```\n   *\n   * @param contextConfig The context configuration. See {@link module:core/context~Context}.\n   */\n  create(contextConfig = {}) {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this._contextConfig = contextConfig;\n      return this._create();\n    });\n  }\n  /**\n   * Returns an item instance with the given `itemId`.\n   *\n   * ```ts\n   * const editor1 = watchdog.getItem( 'editor1' );\n   * ```\n   *\n   * @param itemId The item ID.\n   * @returns The item instance or `undefined` if an item with a given ID has not been found.\n   */\n  getItem(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n    return watchdog._item;\n  }\n  /**\n   * Gets the state of the given item. See {@link #state} for a list of available states.\n   *\n   * ```ts\n   * const editor1State = watchdog.getItemState( 'editor1' );\n   * ```\n   *\n   * @param itemId Item ID.\n   * @returns The state of the item.\n   */\n  getItemState(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n    return watchdog.state;\n  }\n  /**\n   * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\n   *\n   * Items can be passed together as an array of objects:\n   *\n   * ```ts\n   * await watchdog.add( [ {\n   * \tid: 'editor1',\n   * \ttype: 'editor',\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\n   * \tconfig: {\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n   * \t},\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n   * } ] );\n   * ```\n   *\n   * Or one by one as objects:\n   *\n   * ```ts\n   * await watchdog.add( {\n   * \tid: 'editor1',\n   * \ttype: 'editor',\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\n   * \tconfig: {\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n   * \t},\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n   * ] );\n   * ```\n   *\n   * Then an instance can be retrieved using the {@link #getItem} method:\n   *\n   * ```ts\n   * const editor1 = watchdog.getItem( 'editor1' );\n   * ```\n   *\n   * Note that this method can be called multiple times, but for performance reasons it is better\n   * to pass all items together.\n   *\n   * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\n   */\n  add(itemConfigurationOrItemConfigurations) {\n    const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n    return Promise.all(itemConfigurations.map(item => {\n      return this._actionQueues.enqueue(item.id, () => {\n        if (this.state === 'destroyed') {\n          throw new Error('Cannot add items to destroyed watchdog.');\n        }\n        if (!this._context) {\n          throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n        }\n        let watchdog;\n        if (this._watchdogs.has(item.id)) {\n          throw new Error(`Item with the given id is already added: '${item.id}'.`);\n        }\n        if (item.type === 'editor') {\n          watchdog = new EditorWatchdog(null, this._watchdogConfig);\n          watchdog.setCreator(item.creator);\n          watchdog._setExcludedProperties(this._contextProps);\n          if (item.destructor) {\n            watchdog.setDestructor(item.destructor);\n          }\n          this._watchdogs.set(item.id, watchdog);\n          // Enqueue the internal watchdog errors within the main queue.\n          // And propagate the internal `error` events as `itemError` event.\n          watchdog.on('error', (evt, {\n            error,\n            causesRestart\n          }) => {\n            this._fire('itemError', {\n              itemId: item.id,\n              error\n            });\n            // Do not enqueue the item restart action if the item will not restart.\n            if (!causesRestart) {\n              return;\n            }\n            this._actionQueues.enqueue(item.id, () => new Promise(res => {\n              const rethrowRestartEventOnce = () => {\n                watchdog.off('restart', rethrowRestartEventOnce);\n                this._fire('itemRestart', {\n                  itemId: item.id\n                });\n                res();\n              };\n              watchdog.on('restart', rethrowRestartEventOnce);\n            }));\n          });\n          return watchdog.create(item.sourceElementOrData, item.config, this._context);\n        } else {\n          throw new Error(`Not supported item type: '${item.type}'.`);\n        }\n      });\n    }));\n  }\n  /**\n   * Removes and destroys item(s) with given ID(s).\n   *\n   * ```ts\n   * await watchdog.remove( 'editor1' );\n   * ```\n   *\n   * Or\n   *\n   * ```ts\n   * await watchdog.remove( [ 'editor1', 'editor2' ] );\n   * ```\n   *\n   * @param itemIdOrItemIds Item ID or an array of item IDs.\n   */\n  remove(itemIdOrItemIds) {\n    const itemIds = toArray(itemIdOrItemIds);\n    return Promise.all(itemIds.map(itemId => {\n      return this._actionQueues.enqueue(itemId, () => {\n        const watchdog = this._getWatchdog(itemId);\n        this._watchdogs.delete(itemId);\n        return watchdog.destroy();\n      });\n    }));\n  }\n  /**\n   * Destroys the context watchdog and all added items.\n   * Once the context watchdog is destroyed, new items cannot be added.\n   *\n   * ```ts\n   * await watchdog.destroy();\n   * ```\n   */\n  destroy() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'destroyed';\n      this._fire('stateChange');\n      super.destroy();\n      return this._destroy();\n    });\n  }\n  /**\n   * Restarts the context watchdog.\n   */\n  _restart() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'initializing';\n      this._fire('stateChange');\n      return this._destroy().catch(err => {\n        console.error('An error happened during destroying the context or items.', err);\n      }).then(() => this._create()).then(() => this._fire('restart'));\n    });\n  }\n  /**\n   * Initializes the context watchdog.\n   */\n  _create() {\n    return Promise.resolve().then(() => {\n      this._startErrorHandling();\n      return this._creator(this._contextConfig);\n    }).then(context => {\n      this._context = context;\n      this._contextProps = getSubNodes(this._context);\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => {\n        watchdog._setExcludedProperties(this._contextProps);\n        return watchdog.create(undefined, undefined, this._context);\n      }));\n    });\n  }\n  /**\n   * Destroys the context instance and all added items.\n   */\n  _destroy() {\n    return Promise.resolve().then(() => {\n      this._stopErrorHandling();\n      const context = this._context;\n      this._context = null;\n      this._contextProps = new Set();\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => watchdog.destroy()))\n      // Context destructor destroys each editor.\n      .then(() => this._destructor(context));\n    });\n  }\n  /**\n   * Returns the watchdog for a given item ID.\n   *\n   * @param itemId Item ID.\n   */\n  _getWatchdog(itemId) {\n    const watchdog = this._watchdogs.get(itemId);\n    if (!watchdog) {\n      throw new Error(`Item with the given id was not registered: ${itemId}.`);\n    }\n    return watchdog;\n  }\n  /**\n   * Checks whether an error comes from the context instance and not from the item instances.\n   *\n   * @internal\n   */\n  _isErrorComingFromThisItem(error) {\n    for (const watchdog of this._watchdogs.values()) {\n      if (watchdog._isErrorComingFromThisItem(error)) {\n        return false;\n      }\n    }\n    return areConnectedThroughProperties(this._context, error.context);\n  }\n}\n/**\n * Manager of action queues that allows queuing async functions.\n */\nclass ActionQueues {\n  constructor() {\n    this._onEmptyCallbacks = [];\n    this._queues = new Map();\n    this._activeActions = 0;\n  }\n  /**\n   * Used to register callbacks that will be run when the queue becomes empty.\n   *\n   * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\n   */\n  onEmpty(onEmptyCallback) {\n    this._onEmptyCallbacks.push(onEmptyCallback);\n  }\n  /**\n   * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\n   *\n   * @param queueId The action queue ID.\n   * @param action A function that should be enqueued.\n   */\n  enqueue(queueId, action) {\n    const isMainAction = queueId === mainQueueId;\n    this._activeActions++;\n    if (!this._queues.get(queueId)) {\n      this._queues.set(queueId, Promise.resolve());\n    }\n    // List all sources of actions that the current action needs to await for.\n    // For the main action wait for all other actions.\n    // For the item action wait only for the item queue and the main queue.\n    const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n    const queueWithAction = awaitedActions.then(action);\n    // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n    const nonErrorQueue = queueWithAction.catch(() => {});\n    this._queues.set(queueId, nonErrorQueue);\n    return queueWithAction.finally(() => {\n      this._activeActions--;\n      if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n        this._onEmptyCallbacks.forEach(cb => cb());\n      }\n    });\n  }\n}\n/**\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\n *\n * @param elementOrArray The value to transform to an array.\n * @returns An array created from data.\n */\nfunction toArray(elementOrArray) {\n  return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}","map":{"version":3,"names":["Watchdog","EditorWatchdog","areConnectedThroughProperties","getSubNodes","mainQueueId","Symbol","ContextWatchdog","constructor","Context","watchdogConfig","_watchdogs","Map","_context","_contextProps","Set","_actionQueues","ActionQueues","_watchdogConfig","_creator","contextConfig","create","_destructor","context","destroy","onEmpty","state","_fire","setCreator","creator","setDestructor","destructor","enqueue","_contextConfig","_create","getItem","itemId","watchdog","_getWatchdog","_item","getItemState","add","itemConfigurationOrItemConfigurations","itemConfigurations","toArray","Promise","all","map","item","id","Error","has","type","_setExcludedProperties","set","on","evt","error","causesRestart","res","rethrowRestartEventOnce","off","sourceElementOrData","config","remove","itemIdOrItemIds","itemIds","delete","_destroy","_restart","catch","err","console","then","resolve","_startErrorHandling","Array","from","values","undefined","_stopErrorHandling","get","_isErrorComingFromThisItem","_onEmptyCallbacks","_queues","_activeActions","onEmptyCallback","push","queueId","action","isMainAction","awaitedActions","queueWithAction","nonErrorQueue","finally","forEach","cb","elementOrArray","isArray"],"sources":["D:/My Work/DubaiMusic/dubai-music/node_modules/@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Watchdog from './watchdog.js';\nimport EditorWatchdog from './editorwatchdog.js';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties.js';\nimport getSubNodes from './utils/getsubnodes.js';\nconst mainQueueId = Symbol('MainQueueId');\n/**\n * A watchdog for the {@link module:core/context~Context} class.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class ContextWatchdog extends Watchdog {\n    /**\n     * The context watchdog class constructor.\n     *\n     * ```ts\n     * const watchdog = new ContextWatchdog( Context );\n     *\n     * await watchdog.create( contextConfiguration );\n     *\n     * await watchdog.add( item );\n     * ```\n     *\n     * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\n     *\n     * @param Context The {@link module:core/context~Context} class.\n     * @param watchdogConfig The watchdog configuration.\n     */\n    constructor(Context, watchdogConfig = {}) {\n        super(watchdogConfig);\n        /**\n         * A map of internal watchdogs for added items.\n         */\n        this._watchdogs = new Map();\n        /**\n         * The current context instance.\n         */\n        this._context = null;\n        /**\n         * Context properties (nodes/references) that are gathered during the initial context creation\n         * and are used to distinguish the origin of an error.\n         */\n        this._contextProps = new Set();\n        /**\n         * An action queue, which is used to handle async functions queuing.\n         */\n        this._actionQueues = new ActionQueues();\n        this._watchdogConfig = watchdogConfig;\n        // Default creator and destructor.\n        this._creator = contextConfig => Context.create(contextConfig);\n        this._destructor = context => context.destroy();\n        this._actionQueues.onEmpty(() => {\n            if (this.state === 'initializing') {\n                this.state = 'ready';\n                this._fire('stateChange');\n            }\n        });\n    }\n    /**\n     * Sets the function that is responsible for the context creation.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setCreator( config => Context.create( config ) );\n     * ```\n     */\n    setCreator(creator) {\n        this._creator = creator;\n    }\n    /**\n     * Sets the function that is responsible for the context destruction.\n     * Overrides the default destruction function, which destroys only the context instance.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setDestructor( context => {\n     * \t// Do something before the context is destroyed.\n     *\n     * \treturn context\n     * \t\t.destroy()\n     * \t\t.then( () => {\n     * \t\t\t// Do something after the context is destroyed.\n     * \t\t} );\n     * } );\n     * ```\n     */\n    setDestructor(destructor) {\n        this._destructor = destructor;\n    }\n    /**\n     * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\n     * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\n     */\n    get context() {\n        return this._context;\n    }\n    /**\n     * Initializes the context watchdog. Once it is created, the watchdog takes care about\n     * recreating the context and the provided items, and starts the error handling mechanism.\n     *\n     * ```ts\n     * await watchdog.create( {\n     * \tplugins: []\n     * } );\n     * ```\n     *\n     * @param contextConfig The context configuration. See {@link module:core/context~Context}.\n     */\n    create(contextConfig = {}) {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this._contextConfig = contextConfig;\n            return this._create();\n        });\n    }\n    /**\n     * Returns an item instance with the given `itemId`.\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * @param itemId The item ID.\n     * @returns The item instance or `undefined` if an item with a given ID has not been found.\n     */\n    getItem(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog._item;\n    }\n    /**\n     * Gets the state of the given item. See {@link #state} for a list of available states.\n     *\n     * ```ts\n     * const editor1State = watchdog.getItemState( 'editor1' );\n     * ```\n     *\n     * @param itemId Item ID.\n     * @returns The state of the item.\n     */\n    getItemState(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog.state;\n    }\n    /**\n     * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\n     *\n     * Items can be passed together as an array of objects:\n     *\n     * ```ts\n     * await watchdog.add( [ {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * } ] );\n     * ```\n     *\n     * Or one by one as objects:\n     *\n     * ```ts\n     * await watchdog.add( {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * ] );\n     * ```\n     *\n     * Then an instance can be retrieved using the {@link #getItem} method:\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * Note that this method can be called multiple times, but for performance reasons it is better\n     * to pass all items together.\n     *\n     * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\n     */\n    add(itemConfigurationOrItemConfigurations) {\n        const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n        return Promise.all(itemConfigurations.map(item => {\n            return this._actionQueues.enqueue(item.id, () => {\n                if (this.state === 'destroyed') {\n                    throw new Error('Cannot add items to destroyed watchdog.');\n                }\n                if (!this._context) {\n                    throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n                }\n                let watchdog;\n                if (this._watchdogs.has(item.id)) {\n                    throw new Error(`Item with the given id is already added: '${item.id}'.`);\n                }\n                if (item.type === 'editor') {\n                    watchdog = new EditorWatchdog(null, this._watchdogConfig);\n                    watchdog.setCreator(item.creator);\n                    watchdog._setExcludedProperties(this._contextProps);\n                    if (item.destructor) {\n                        watchdog.setDestructor(item.destructor);\n                    }\n                    this._watchdogs.set(item.id, watchdog);\n                    // Enqueue the internal watchdog errors within the main queue.\n                    // And propagate the internal `error` events as `itemError` event.\n                    watchdog.on('error', (evt, { error, causesRestart }) => {\n                        this._fire('itemError', { itemId: item.id, error });\n                        // Do not enqueue the item restart action if the item will not restart.\n                        if (!causesRestart) {\n                            return;\n                        }\n                        this._actionQueues.enqueue(item.id, () => new Promise(res => {\n                            const rethrowRestartEventOnce = () => {\n                                watchdog.off('restart', rethrowRestartEventOnce);\n                                this._fire('itemRestart', { itemId: item.id });\n                                res();\n                            };\n                            watchdog.on('restart', rethrowRestartEventOnce);\n                        }));\n                    });\n                    return watchdog.create(item.sourceElementOrData, item.config, this._context);\n                }\n                else {\n                    throw new Error(`Not supported item type: '${item.type}'.`);\n                }\n            });\n        }));\n    }\n    /**\n     * Removes and destroys item(s) with given ID(s).\n     *\n     * ```ts\n     * await watchdog.remove( 'editor1' );\n     * ```\n     *\n     * Or\n     *\n     * ```ts\n     * await watchdog.remove( [ 'editor1', 'editor2' ] );\n     * ```\n     *\n     * @param itemIdOrItemIds Item ID or an array of item IDs.\n     */\n    remove(itemIdOrItemIds) {\n        const itemIds = toArray(itemIdOrItemIds);\n        return Promise.all(itemIds.map(itemId => {\n            return this._actionQueues.enqueue(itemId, () => {\n                const watchdog = this._getWatchdog(itemId);\n                this._watchdogs.delete(itemId);\n                return watchdog.destroy();\n            });\n        }));\n    }\n    /**\n     * Destroys the context watchdog and all added items.\n     * Once the context watchdog is destroyed, new items cannot be added.\n     *\n     * ```ts\n     * await watchdog.destroy();\n     * ```\n     */\n    destroy() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'destroyed';\n            this._fire('stateChange');\n            super.destroy();\n            return this._destroy();\n        });\n    }\n    /**\n     * Restarts the context watchdog.\n     */\n    _restart() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'initializing';\n            this._fire('stateChange');\n            return this._destroy()\n                .catch(err => {\n                console.error('An error happened during destroying the context or items.', err);\n            })\n                .then(() => this._create())\n                .then(() => this._fire('restart'));\n        });\n    }\n    /**\n     * Initializes the context watchdog.\n     */\n    _create() {\n        return Promise.resolve()\n            .then(() => {\n            this._startErrorHandling();\n            return this._creator(this._contextConfig);\n        })\n            .then(context => {\n            this._context = context;\n            this._contextProps = getSubNodes(this._context);\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => {\n                watchdog._setExcludedProperties(this._contextProps);\n                return watchdog.create(undefined, undefined, this._context);\n            }));\n        });\n    }\n    /**\n     * Destroys the context instance and all added items.\n     */\n    _destroy() {\n        return Promise.resolve()\n            .then(() => {\n            this._stopErrorHandling();\n            const context = this._context;\n            this._context = null;\n            this._contextProps = new Set();\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => watchdog.destroy()))\n                // Context destructor destroys each editor.\n                .then(() => this._destructor(context));\n        });\n    }\n    /**\n     * Returns the watchdog for a given item ID.\n     *\n     * @param itemId Item ID.\n     */\n    _getWatchdog(itemId) {\n        const watchdog = this._watchdogs.get(itemId);\n        if (!watchdog) {\n            throw new Error(`Item with the given id was not registered: ${itemId}.`);\n        }\n        return watchdog;\n    }\n    /**\n     * Checks whether an error comes from the context instance and not from the item instances.\n     *\n     * @internal\n     */\n    _isErrorComingFromThisItem(error) {\n        for (const watchdog of this._watchdogs.values()) {\n            if (watchdog._isErrorComingFromThisItem(error)) {\n                return false;\n            }\n        }\n        return areConnectedThroughProperties(this._context, error.context);\n    }\n}\n/**\n * Manager of action queues that allows queuing async functions.\n */\nclass ActionQueues {\n    constructor() {\n        this._onEmptyCallbacks = [];\n        this._queues = new Map();\n        this._activeActions = 0;\n    }\n    /**\n     * Used to register callbacks that will be run when the queue becomes empty.\n     *\n     * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\n     */\n    onEmpty(onEmptyCallback) {\n        this._onEmptyCallbacks.push(onEmptyCallback);\n    }\n    /**\n     * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\n     *\n     * @param queueId The action queue ID.\n     * @param action A function that should be enqueued.\n     */\n    enqueue(queueId, action) {\n        const isMainAction = queueId === mainQueueId;\n        this._activeActions++;\n        if (!this._queues.get(queueId)) {\n            this._queues.set(queueId, Promise.resolve());\n        }\n        // List all sources of actions that the current action needs to await for.\n        // For the main action wait for all other actions.\n        // For the item action wait only for the item queue and the main queue.\n        const awaitedActions = isMainAction ?\n            Promise.all(this._queues.values()) :\n            Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n        const queueWithAction = awaitedActions.then(action);\n        // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n        const nonErrorQueue = queueWithAction.catch(() => { });\n        this._queues.set(queueId, nonErrorQueue);\n        return queueWithAction.finally(() => {\n            this._activeActions--;\n            if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n                this._onEmptyCallbacks.forEach(cb => cb());\n            }\n        });\n    }\n}\n/**\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\n *\n * @param elementOrArray The value to transform to an array.\n * @returns An array created from data.\n */\nfunction toArray(elementOrArray) {\n    return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,eAAe;AACpC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,6BAA6B,MAAM,0CAA0C;AACpF,OAAOC,WAAW,MAAM,wBAAwB;AAChD,MAAMC,WAAW,GAAGC,MAAM,CAAC,aAAa,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,eAAe,SAASN,QAAQ,CAAC;EAClD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,WAAWA,CAACC,OAAO,EAAEC,cAAc,GAAG,CAAC,CAAC,EAAE;IACtC,KAAK,CAACA,cAAc,CAAC;IACrB;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC3B;AACR;AACA;IACQ,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB;AACR;AACA;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC9B;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,IAAIC,YAAY,CAAC,CAAC;IACvC,IAAI,CAACC,eAAe,GAAGR,cAAc;IACrC;IACA,IAAI,CAACS,QAAQ,GAAGC,aAAa,IAAIX,OAAO,CAACY,MAAM,CAACD,aAAa,CAAC;IAC9D,IAAI,CAACE,WAAW,GAAGC,OAAO,IAAIA,OAAO,CAACC,OAAO,CAAC,CAAC;IAC/C,IAAI,CAACR,aAAa,CAACS,OAAO,CAAC,MAAM;MAC7B,IAAI,IAAI,CAACC,KAAK,KAAK,cAAc,EAAE;QAC/B,IAAI,CAACA,KAAK,GAAG,OAAO;QACpB,IAAI,CAACC,KAAK,CAAC,aAAa,CAAC;MAC7B;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,UAAUA,CAACC,OAAO,EAAE;IAChB,IAAI,CAACV,QAAQ,GAAGU,OAAO;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAaA,CAACC,UAAU,EAAE;IACtB,IAAI,CAACT,WAAW,GAAGS,UAAU;EACjC;EACA;AACJ;AACA;AACA;EACI,IAAIR,OAAOA,CAAA,EAAG;IACV,OAAO,IAAI,CAACV,QAAQ;EACxB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,MAAMA,CAACD,aAAa,GAAG,CAAC,CAAC,EAAE;IACvB,OAAO,IAAI,CAACJ,aAAa,CAACgB,OAAO,CAAC3B,WAAW,EAAE,MAAM;MACjD,IAAI,CAAC4B,cAAc,GAAGb,aAAa;MACnC,OAAO,IAAI,CAACc,OAAO,CAAC,CAAC;IACzB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,OAAOA,CAACC,MAAM,EAAE;IACZ,MAAMC,QAAQ,GAAG,IAAI,CAACC,YAAY,CAACF,MAAM,CAAC;IAC1C,OAAOC,QAAQ,CAACE,KAAK;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAYA,CAACJ,MAAM,EAAE;IACjB,MAAMC,QAAQ,GAAG,IAAI,CAACC,YAAY,CAACF,MAAM,CAAC;IAC1C,OAAOC,QAAQ,CAACX,KAAK;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIe,GAAGA,CAACC,qCAAqC,EAAE;IACvC,MAAMC,kBAAkB,GAAGC,OAAO,CAACF,qCAAqC,CAAC;IACzE,OAAOG,OAAO,CAACC,GAAG,CAACH,kBAAkB,CAACI,GAAG,CAACC,IAAI,IAAI;MAC9C,OAAO,IAAI,CAAChC,aAAa,CAACgB,OAAO,CAACgB,IAAI,CAACC,EAAE,EAAE,MAAM;QAC7C,IAAI,IAAI,CAACvB,KAAK,KAAK,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}