{"ast":null,"code":"/*!\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e(require(\"react\"), require(\"prop-types\"), require(\"@ckeditor/ckeditor5-watchdog\")) : \"function\" == typeof define && define.amd ? define([\"react\", \"prop-types\", \"@ckeditor/ckeditor5-watchdog\"], e) : \"object\" == typeof exports ? exports.CKEditor = e(require(\"react\"), require(\"prop-types\"), require(\"@ckeditor/ckeditor5-watchdog\")) : t.CKEditor = e(t.react, t[\"prop-types\"], t[\"@ckeditor/ckeditor5-watchdog\"]);\n}(self, (t, e, o) => (() => {\n  \"use strict\";\n\n  var r = {\n      546: t => {\n        t.exports = o;\n      },\n      949: t => {\n        t.exports = e;\n      },\n      155: e => {\n        e.exports = t;\n      }\n    },\n    n = {};\n  function a(t) {\n    var e = n[t];\n    if (void 0 !== e) return e.exports;\n    var o = n[t] = {\n      exports: {}\n    };\n    return r[t](o, o.exports, a), o.exports;\n  }\n  a.n = t => {\n    var e = t && t.__esModule ? () => t.default : () => t;\n    return a.d(e, {\n      a: e\n    }), e;\n  }, a.d = (t, e) => {\n    for (var o in e) a.o(e, o) && !a.o(t, o) && Object.defineProperty(t, o, {\n      enumerable: !0,\n      get: e[o]\n    });\n  }, a.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), a.r = t => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n  };\n  var i = {};\n  return (() => {\n    a.r(i), a.d(i, {\n      CKEditor: () => h,\n      CKEditorContext: () => d,\n      useMultiRootEditor: () => C\n    });\n    var t = a(155),\n      e = a.n(t),\n      o = a(949),\n      r = a.n(o);\n    const n = new Array(256).fill(\"\").map((t, e) => (\"0\" + e.toString(16)).slice(-2));\n    var s = a(546);\n    const c = e().createContext(\"contextWatchdog\");\n    class d extends e().Component {\n      constructor(t, e) {\n        super(t, e), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);\n      }\n      shouldComponentUpdate(t) {\n        return this._shouldComponentUpdate(t);\n      }\n      async _shouldComponentUpdate(t) {\n        return t.id !== this.props.id && (this.contextWatchdog && (await this.contextWatchdog.destroy()), await this._initializeContextWatchdog(t.config)), t.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(t.config), !0) : this.props.children !== t.children;\n      }\n      render() {\n        return e().createElement(c.Provider, {\n          value: this.contextWatchdog\n        }, this.props.children);\n      }\n      componentWillUnmount() {\n        this._destroyContext();\n      }\n      async _initializeContextWatchdog(t) {\n        this.contextWatchdog = new s.ContextWatchdog(this.props.context, this.props.watchdogConfig), this.contextWatchdog.on(\"error\", (t, e) => {\n          this.props.onError(e.error, {\n            phase: \"runtime\",\n            willContextRestart: e.causesRestart\n          });\n        }), this.contextWatchdog.on(\"stateChange\", () => {\n          \"ready\" === this.contextWatchdog.state && this.props.onReady && this.props.onReady(this.contextWatchdog.context);\n        }), await this.contextWatchdog.create(t).catch(t => {\n          this.props.onError(t, {\n            phase: \"initialization\",\n            willContextRestart: !1\n          });\n        });\n      }\n      async _destroyContext() {\n        this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);\n      }\n    }\n    d.defaultProps = {\n      isLayoutReady: !0,\n      onError: (t, e) => console.error(t, e)\n    }, d.propTypes = {\n      id: r().string,\n      isLayoutReady: r().bool,\n      context: r().func,\n      watchdogConfig: r().object,\n      config: r().object,\n      onReady: r().func,\n      onError: r().func\n    };\n    class u {\n      constructor(t, e) {\n        this._releaseLock = null, this._value = null, this._afterMountCallbacks = [], this._state = {\n          destroyedBeforeInitialization: !1,\n          mountingInProgress: null\n        }, this.release = function (t) {\n          let e = null;\n          return (...o) => (e || (e = {\n            current: t(...o)\n          }), e.current);\n        }(() => {\n          const {\n            _releaseLock: t,\n            _state: e,\n            _element: o,\n            _lifecycle: r\n          } = this;\n          e.mountingInProgress ? e.mountingInProgress.then(() => r.unmount({\n            element: o,\n            mountResult: this.value\n          })).catch(t => {\n            console.error(\"Semaphore unmounting error:\", t);\n          }).then(t.resolve).then(() => {\n            this._value = null;\n          }) : (e.destroyedBeforeInitialization = !0, t.resolve());\n        }), this._element = t, this._lifecycle = e, this._lock();\n      }\n      get value() {\n        return this._value;\n      }\n      unsafeSetValue(t) {\n        this._value = t, this._afterMountCallbacks.forEach(e => e(t)), this._afterMountCallbacks = [];\n      }\n      runAfterMount(t) {\n        const {\n          _value: e,\n          _afterMountCallbacks: o\n        } = this;\n        e ? t(e) : o.push(t);\n      }\n      _lock() {\n        const {\n            _semaphores: t\n          } = u,\n          {\n            _state: e,\n            _element: o,\n            _lifecycle: r\n          } = this,\n          n = t.get(o) || Promise.resolve(null),\n          a = function () {\n            const t = {\n              resolve: null,\n              promise: null\n            };\n            return t.promise = new Promise(e => {\n              t.resolve = e;\n            }), t;\n          }();\n        this._releaseLock = a;\n        const i = n.then(() => e.destroyedBeforeInitialization ? Promise.resolve(void 0) : (e.mountingInProgress = r.mount().then(t => (t && this.unsafeSetValue(t), t)), e.mountingInProgress)).then(async t => {\n          t && r.afterMount && (await r.afterMount({\n            element: o,\n            mountResult: t\n          }));\n        }).then(() => a.promise).catch(t => {\n          console.error(\"Semaphore mounting error:\", t);\n        }).then(() => {\n          t.get(o) === i && t.delete(o);\n        });\n        t.set(o, i);\n      }\n    }\n    u._semaphores = new Map();\n    const l = \"Lock from React integration (@ckeditor/ckeditor5-react)\";\n    class h extends e().Component {\n      constructor(t) {\n        super(t), this.domContainer = e().createRef(), this.editorSemaphore = null;\n        const {\n          CKEDITOR_VERSION: o\n        } = window;\n        if (o) {\n          const [t] = o.split(\".\").map(Number);\n          t < 37 && console.warn(\"The <CKEditor> component requires using CKEditor 5 in version 37 or higher.\");\n        } else console.warn('Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.');\n      }\n      get _semaphoreValue() {\n        const {\n          editorSemaphore: t\n        } = this;\n        return t ? t.value : null;\n      }\n      get watchdog() {\n        const {\n          _semaphoreValue: t\n        } = this;\n        return t ? t.watchdog : null;\n      }\n      get editor() {\n        const {\n          _semaphoreValue: t\n        } = this;\n        return t ? t.instance : null;\n      }\n      shouldComponentUpdate(t) {\n        const {\n          props: e,\n          editorSemaphore: o\n        } = this;\n        return t.id !== e.id || t.disableWatchdog !== e.disableWatchdog || (o && (o.runAfterMount(({\n          instance: o\n        }) => {\n          this._shouldUpdateEditorData(e, t, o) && o.data.set(t.data);\n        }), \"disabled\" in t && o.runAfterMount(({\n          instance: e\n        }) => {\n          t.disabled ? e.enableReadOnlyMode(l) : e.disableReadOnlyMode(l);\n        })), !1);\n      }\n      componentDidMount() {\n        this._initLifeCycleSemaphore();\n      }\n      componentDidUpdate() {\n        this._initLifeCycleSemaphore();\n      }\n      componentWillUnmount() {\n        this._unlockLifeCycleSemaphore();\n      }\n      _unlockLifeCycleSemaphore() {\n        this.editorSemaphore && (this.editorSemaphore.release(), this.editorSemaphore = null);\n      }\n      _initLifeCycleSemaphore() {\n        this._unlockLifeCycleSemaphore(), this.editorSemaphore = new u(this.domContainer.current, {\n          mount: async () => this._initializeEditor(),\n          afterMount: ({\n            mountResult: t\n          }) => {\n            const {\n              onReady: e\n            } = this.props;\n            e && null !== this.domContainer.current && e(t.instance);\n          },\n          unmount: async ({\n            element: t,\n            mountResult: e\n          }) => {\n            const {\n              onAfterDestroy: o\n            } = this.props;\n            try {\n              await this._destroyEditor(e), t.innerHTML = \"\";\n            } finally {\n              o && o(e.instance);\n            }\n          }\n        });\n      }\n      render() {\n        return e().createElement(\"div\", {\n          ref: this.domContainer\n        });\n      }\n      async _initializeEditor() {\n        if (this.props.disableWatchdog) {\n          return {\n            instance: await this._createEditor(this.domContainer.current, this._getConfig()),\n            watchdog: null\n          };\n        }\n        const t = (() => this.context instanceof s.ContextWatchdog ? new p(this.context) : new h._EditorWatchdog(this.props.editor, this.props.watchdogConfig))(),\n          e = {\n            current: 0\n          };\n        return t.setCreator(async (o, r) => {\n          const {\n              editorSemaphore: n\n            } = this,\n            {\n              onAfterDestroy: a\n            } = this.props;\n          e.current > 0 && a && n && n.value && n.value.instance && a(n.value.instance);\n          const i = await this._createEditor(o, r);\n          return e.current > 0 && (n.unsafeSetValue({\n            instance: i,\n            watchdog: t\n          }), setTimeout(() => {\n            this.props.onReady && this.props.onReady(t.editor);\n          })), e.current++, i;\n        }), t.on(\"error\", (t, {\n          error: e,\n          causesRestart: o\n        }) => {\n          (this.props.onError || console.error)(e, {\n            phase: \"runtime\",\n            willEditorRestart: o\n          });\n        }), await t.create(this.domContainer.current, this._getConfig()).catch(t => {\n          (this.props.onError || console.error)(t, {\n            phase: \"initialization\",\n            willEditorRestart: !1\n          });\n        }), {\n          watchdog: t,\n          instance: t.editor\n        };\n      }\n      _createEditor(t, e) {\n        return this.props.editor.create(t, e).then(t => {\n          \"disabled\" in this.props && this.props.disabled && t.enableReadOnlyMode(l);\n          const e = t.model.document,\n            o = t.editing.view.document;\n          return e.on(\"change:data\", e => {\n            this.props.onChange && this.props.onChange(e, t);\n          }), o.on(\"focus\", e => {\n            this.props.onFocus && this.props.onFocus(e, t);\n          }), o.on(\"blur\", e => {\n            this.props.onBlur && this.props.onBlur(e, t);\n          }), t;\n        });\n      }\n      async _destroyEditor(t) {\n        const {\n          watchdog: e,\n          instance: o\n        } = t;\n        return new Promise((t, r) => {\n          setTimeout(async () => {\n            try {\n              if (e) return await e.destroy(), t();\n              if (o) return await o.destroy(), t();\n              t();\n            } catch (t) {\n              console.error(t), r(t);\n            }\n          });\n        });\n      }\n      _shouldUpdateEditorData(t, e, o) {\n        return t.data !== e.data && o.data.get() !== e.data;\n      }\n      _getConfig() {\n        const t = this.props.config || {};\n        return this.props.data && t.initialData && console.warn(\"Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified.\"), {\n          ...t,\n          initialData: t.initialData || this.props.data || \"\"\n        };\n      }\n    }\n    h.contextType = c, h.propTypes = {\n      editor: r().func.isRequired,\n      data: r().string,\n      config: r().object,\n      disableWatchdog: r().bool,\n      watchdogConfig: r().object,\n      onChange: r().func,\n      onReady: r().func,\n      onFocus: r().func,\n      onBlur: r().func,\n      onError: r().func,\n      disabled: r().bool,\n      id: r().any\n    }, h._EditorWatchdog = s.EditorWatchdog;\n    class p {\n      constructor(t) {\n        this._contextWatchdog = t, this._id = function () {\n          const t = 4294967296 * Math.random() >>> 0,\n            e = 4294967296 * Math.random() >>> 0,\n            o = 4294967296 * Math.random() >>> 0,\n            r = 4294967296 * Math.random() >>> 0;\n          return \"e\" + n[255 & t] + n[t >> 8 & 255] + n[t >> 16 & 255] + n[t >> 24 & 255] + n[255 & e] + n[e >> 8 & 255] + n[e >> 16 & 255] + n[e >> 24 & 255] + n[255 & o] + n[o >> 8 & 255] + n[o >> 16 & 255] + n[o >> 24 & 255] + n[255 & r] + n[r >> 8 & 255] + n[r >> 16 & 255] + n[r >> 24 & 255];\n        }();\n      }\n      setCreator(t) {\n        this._creator = t;\n      }\n      create(t, e) {\n        return this._contextWatchdog.add({\n          sourceElementOrData: t,\n          config: e,\n          creator: this._creator,\n          id: this._id,\n          type: \"editor\"\n        });\n      }\n      on(t, e) {\n        this._contextWatchdog.on(\"itemError\", (t, {\n          itemId: o,\n          error: r\n        }) => {\n          o === this._id && e(null, {\n            error: r,\n            causesRestart: void 0\n          });\n        });\n      }\n      destroy() {\n        return \"ready\" === this._contextWatchdog.state ? this._contextWatchdog.remove(this._id) : Promise.resolve();\n      }\n      get editor() {\n        return this._contextWatchdog.getItem(this._id);\n      }\n    }\n    function f(...t) {\n      return e => {\n        t.forEach(t => {\n          \"function\" == typeof t ? t(e) : null != t && (t.current = e);\n        });\n      };\n    }\n    function g(t, e) {\n      for (const t of Object.getOwnPropertyNames(e)) delete e[t];\n      for (const [o, r] of Object.entries(t)) r !== e && \"prototype\" !== o && \"__proto__\" !== o && (e[o] = r);\n      return e;\n    }\n    const m = e => {\n      const o = (0, t.useRef)();\n      return o.current = e, (0, t.useCallback)((...t) => o.current(...t), []);\n    };\n    function y(t, e) {\n      return e.length = 0, e.push(...t), e;\n    }\n    const b = (e, o, r) => {\n        ((e, o) => {\n          const r = (0, t.useRef)(null);\n          ((t, e) => {\n            if (t === e) return !0;\n            if (!t || !e) return !1;\n            for (let o = 0; o < t.length; ++o) if (t[o] !== e[o]) return !1;\n            return !0;\n          })(r.current, o) || (r.current = [...o], e());\n        })(() => {\n          e && e.runAfterMount(o);\n        }, [e, ...r]);\n      },\n      w = \"Lock from React integration (@ckeditor/ckeditor5-react)\",\n      _ = (0, t.memo)((0, t.forwardRef)(({\n        id: o,\n        semaphore: r,\n        rootName: n\n      }, a) => {\n        const i = (0, t.useRef)(null);\n        return (0, t.useEffect)(() => {\n          let t, e;\n          return r.runAfterMount(({\n            instance: o\n          }) => {\n            i.current && (e = o, t = o.ui.view.createEditable(n, i.current), o.ui.addEditable(t), o.editing.view.forceRender());\n          }), () => {\n            t && i.current && e && \"destroyed\" !== e.state && e.ui.removeEditable(t);\n          };\n        }, [r.revision]), e().createElement(\"div\", {\n          key: r.revision,\n          id: o,\n          ref: f(a, i)\n        });\n      }));\n    _.displayName = \"EditorEditable\";\n    const R = (0, t.forwardRef)(({\n      editor: o\n    }, r) => {\n      const n = (0, t.useRef)(null);\n      return (0, t.useEffect)(() => {\n        const t = n.current;\n        if (!o || !t) return;\n        const e = o.ui.view.toolbar.element;\n        return t && t.appendChild(e), () => {\n          t && t.removeChild(e);\n        };\n      }, [o && o.id]), e().createElement(\"div\", {\n        ref: f(n, r)\n      });\n    });\n    R.displayName = \"EditorToolbarWrapper\";\n    const C = o => {\n      const r = (0, t.useRef)(o.semaphoreElement || null),\n        n = (() => {\n          const e = (0, t.useRef)(null),\n            [o, r] = (0, t.useState)(() => Date.now()),\n            n = () => {\n              r(Date.now());\n            },\n            a = (t = !0) => {\n              e.current && (e.current.release(), e.current = null), t && r(Date.now());\n            },\n            i = t => {\n              e.current && e.current.runAfterMount(t);\n            };\n          return {\n            get current() {\n              return e.current;\n            },\n            revision: o,\n            createAttributeRef: t => ({\n              get current() {\n                return e.current && e.current.value ? e.current.value[t] : null;\n              }\n            }),\n            unsafeSetValue: t => {\n              var o;\n              null === (o = e.current) || void 0 === o || o.unsafeSetValue(t), n();\n            },\n            release: a,\n            replace: t => {\n              a(!1), e.current = t(), n(), i(n);\n            },\n            runAfterMount: i\n          };\n        })(),\n        a = {\n          watchdog: n.createAttributeRef(\"watchdog\"),\n          instance: n.createAttributeRef(\"instance\")\n        },\n        i = (0, t.useContext)(c),\n        [d, l] = (0, t.useState)(() => Object.keys(o.data)),\n        [h, f] = (0, t.useState)({\n          ...o.data\n        }),\n        [C, v] = (0, t.useState)({\n          ...o.rootsAttributes\n        }),\n        E = (0, t.useRef)(!0);\n      (0, t.useEffect)(() => {\n        const t = r.current;\n        if (t && !1 !== o.isLayoutReady) return n.replace(() => new u(t, {\n          mount: A,\n          afterMount: ({\n            mountResult: t\n          }) => {\n            const {\n              onReady: e\n            } = o;\n            e && null !== r.current && e(t.instance);\n          },\n          unmount: async ({\n            element: t,\n            mountResult: e\n          }) => {\n            const {\n              onAfterDestroy: r\n            } = o;\n            try {\n              await O(e), t.innerHTML = \"\";\n            } finally {\n              r && r(e.instance);\n            }\n          }\n        })), () => {\n          n.release(!1);\n        };\n      }, [o.id, o.isLayoutReady]);\n      const x = () => {\n          const t = o.config || {};\n          return o.data && t.initialData && console.warn(\"Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified.\"), {\n            ...t,\n            rootsAttributes: C\n          };\n        },\n        k = m((t, e) => {\n          const r = t.model.document;\n          if (!o.disableTwoWayDataBinding) {\n            const e = {},\n              o = {};\n            r.differ.getChanges().forEach(o => {\n              let r;\n              if (r = \"insert\" == o.type || \"remove\" == o.type ? o.position.root : o.range.root, !r.isAttached()) return;\n              const {\n                rootName: n\n              } = r;\n              e[n] = t.getData({\n                rootName: n\n              });\n            }), r.differ.getChangedRoots().forEach(r => {\n              if (r.state) return void (void 0 !== e[r.name] && delete e[r.name]);\n              const n = r.name;\n              o[n] = t.getRootAttributes(n);\n            }), Object.keys(e).length && f(t => ({\n              ...t,\n              ...e\n            })), Object.keys(o).length && v(t => ({\n              ...t,\n              ...o\n            }));\n          }\n          o.onChange && o.onChange(e, t);\n        }),\n        W = m((t, e, r) => {\n          const n = r.rootName;\n          o.disableTwoWayDataBinding || (f(e => ({\n            ...e,\n            [n]: t.getData({\n              rootName: n\n            })\n          })), v(e => ({\n            ...e,\n            [n]: t.getRootAttributes(n)\n          }))), l(t => {\n            return e = [...t, r.rootName], Array.from(new Set(e));\n            var e;\n          });\n        }),\n        S = m((t, e, r) => {\n          const n = r.rootName;\n          o.disableTwoWayDataBinding || (f(t => {\n            const {\n              [n]: e,\n              ...o\n            } = t;\n            return {\n              ...o\n            };\n          }), v(t => {\n            const {\n              [n]: e,\n              ...o\n            } = t;\n            return {\n              ...o\n            };\n          })), l(t => t.filter(t => t !== n));\n        }),\n        M = m((t, e) => (g({\n          ...o.rootsAttributes\n        }, C), g({\n          ...o.data\n        }, h), y(Object.keys(o.data), d), o.editor.create(t, e).then(t => {\n          const e = t.getFullData();\n          g({\n            ...e\n          }, h), g({\n            ...t.getRootsAttributes()\n          }, C), y(Object.keys(e), d), o.disabled && t.enableReadOnlyMode(w);\n          const r = t.model.document,\n            n = t.editing.view.document;\n          return r.on(\"change:data\", e => k(t, e)), t.on(\"addRoot\", (e, o) => W(t, e, o)), t.on(\"detachRoot\", (e, o) => S(t, e, o)), n.on(\"focus\", e => {\n            o.onFocus && o.onFocus(e, t);\n          }), n.on(\"blur\", e => {\n            o.onBlur && o.onBlur(e, t);\n          }), t;\n        }))),\n        O = t => {\n          const {\n            watchdog: e,\n            instance: o\n          } = t;\n          return new Promise((t, r) => {\n            setTimeout(async () => {\n              try {\n                if (e) return await e.destroy(), t();\n                if (o) return await o.destroy(), t();\n                t();\n              } catch (t) {\n                console.error(t), r(t);\n              }\n            });\n          });\n        },\n        A = async () => {\n          if (o.disableWatchdog) {\n            return {\n              instance: await M(o.data, x()),\n              watchdog: null\n            };\n          }\n          const t = i instanceof s.ContextWatchdog ? new p(i) : new s.EditorWatchdog(o.editor, o.watchdogConfig),\n            e = {\n              current: 0\n            };\n          return t.setCreator(async (r, i) => {\n            const {\n              onAfterDestroy: s\n            } = o;\n            e.current > 0 && s && a.instance.current && s(a.instance.current);\n            const c = await M(r, i);\n            return e.current > 0 && (n.unsafeSetValue({\n              instance: c,\n              watchdog: t\n            }), setTimeout(() => {\n              o.onReady && o.onReady(t.editor);\n            })), e.current++, c;\n          }), t.on(\"error\", (t, {\n            error: e,\n            causesRestart: r\n          }) => {\n            (o.onError || console.error)(e, {\n              phase: \"runtime\",\n              willEditorRestart: r\n            });\n          }), await t.create(h, x()).catch(t => {\n            throw (o.onError || console.error)(t, {\n              phase: \"initialization\",\n              willEditorRestart: !1\n            }), t;\n          }), {\n            watchdog: t,\n            instance: t.editor\n          };\n        },\n        D = (0, t.useCallback)(t => {\n          n.runAfterMount(() => {\n            E.current = !0, f(t);\n          });\n        }, [f]),\n        j = (0, t.useCallback)(t => {\n          n.runAfterMount(() => {\n            E.current = !0, v(t);\n          });\n        }, [v]),\n        T = e().createElement(R, {\n          ref: r,\n          editor: a.instance.current\n        });\n      b(n.current, ({\n        instance: t\n      }) => {\n        o.disabled ? t.enableReadOnlyMode(w) : t.disableReadOnlyMode(w);\n      }, [o.disabled]), b(n.current, ({\n        instance: t\n      }) => {\n        if (E.current) {\n          E.current = !1;\n          const e = Object.keys(h),\n            o = Object.keys(C);\n          if (!e.every(t => o.includes(t))) throw console.error(\"`data` and `attributes` objects must have the same keys (roots).\"), new Error(\"`data` and `attributes` objects must have the same keys (roots).\");\n          const r = t.getFullData(),\n            n = t.getRootsAttributes(),\n            {\n              addedKeys: a,\n              removedKeys: i\n            } = ((t, e) => {\n              const o = Object.keys(t),\n                r = Object.keys(e);\n              return {\n                addedKeys: r.filter(t => !o.includes(t)),\n                removedKeys: o.filter(t => !r.includes(t))\n              };\n            })(r, h || {}),\n            s = e.some(t => void 0 !== r[t] && JSON.stringify(r[t]) !== JSON.stringify(h[t])),\n            c = o.filter(t => JSON.stringify(n[t]) !== JSON.stringify(C[t])),\n            d = e => {\n              e.forEach(e => {\n                t.addRoot(e, {\n                  data: h[e] || \"\",\n                  attributes: (null == C ? void 0 : C[e]) || {},\n                  isUndoable: !0\n                });\n              });\n            },\n            u = e => {\n              e.forEach(e => {\n                t.detachRoot(e, !0);\n              });\n            },\n            l = () => {\n              t.data.set(h, {\n                suppressErrorInCollaboration: !0\n              });\n            },\n            p = (e, o) => {\n              o.forEach(o => {\n                Object.keys(C[o]).forEach(e => {\n                  t.registerRootAttribute(e);\n                }), e.clearAttributes(t.model.document.getRoot(o)), e.setAttributes(C[o], t.model.document.getRoot(o));\n              });\n            };\n          setTimeout(() => {\n            t.model.change(t => {\n              d(a), u(i), s && l(), c.length && p(t, c);\n            });\n          });\n        }\n      }, [h, C]);\n      const L = d.map(t => e().createElement(_, {\n        key: t,\n        id: t,\n        rootName: t,\n        semaphore: n\n      }));\n      return {\n        editor: a.instance.current,\n        editableElements: L,\n        toolbarElement: T,\n        data: h,\n        setData: D,\n        attributes: C,\n        setAttributes: j\n      };\n    };\n  })(), i;\n})());","map":{"version":3,"names":["t","e","exports","module","require","define","amd","CKEditor","react","self","o","n","a","r","__esModule","default","d","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Array","fill","map","toString","slice","c","createContext","Component","constructor","contextWatchdog","props","isLayoutReady","_initializeContextWatchdog","config","shouldComponentUpdate","_shouldComponentUpdate","id","destroy","children","render","createElement","Provider","componentWillUnmount","_destroyContext","s","ContextWatchdog","context","watchdogConfig","on","onError","error","phase","willContextRestart","causesRestart","state","onReady","create","catch","defaultProps","console","propTypes","string","bool","func","object","u","_releaseLock","_value","_afterMountCallbacks","_state","destroyedBeforeInitialization","mountingInProgress","release","current","_element","_lifecycle","then","unmount","element","mountResult","resolve","_lock","unsafeSetValue","forEach","runAfterMount","push","_semaphores","Promise","promise","i","mount","afterMount","delete","set","Map","l","h","domContainer","createRef","editorSemaphore","CKEDITOR_VERSION","window","split","Number","warn","_semaphoreValue","watchdog","editor","instance","disableWatchdog","_shouldUpdateEditorData","data","disabled","enableReadOnlyMode","disableReadOnlyMode","componentDidMount","_initLifeCycleSemaphore","componentDidUpdate","_unlockLifeCycleSemaphore","_initializeEditor","onAfterDestroy","_destroyEditor","innerHTML","ref","_createEditor","_getConfig","p","_EditorWatchdog","setCreator","setTimeout","willEditorRestart","model","document","editing","view","onChange","onFocus","onBlur","initialData","contextType","isRequired","any","EditorWatchdog","_contextWatchdog","_id","Math","random","_creator","add","sourceElementOrData","creator","type","itemId","remove","getItem","f","g","getOwnPropertyNames","entries","m","useRef","useCallback","y","length","b","useInstantEditorEffect","w","_","memo","forwardRef","semaphore","rootName","useEffect","ui","createEditable","addEditable","forceRender","removeEditable","revision","key","displayName","R","toolbar","appendChild","removeChild","C","semaphoreElement","useState","Date","now","refresh","createAttributeRef","replace","useContext","keys","v","rootsAttributes","E","A","O","x","k","disableTwoWayDataBinding","differ","getChanges","position","root","range","isAttached","getData","getChangedRoots","name","getRootAttributes","W","from","Set","S","filter","M","getFullData","getRootsAttributes","D","j","T","every","includes","Error","addedKeys","removedKeys","some","JSON","stringify","addRoot","attributes","isUndoable","detachRoot","_updateEditorData","suppressErrorInCollaboration","_updateEditorAttributes","registerRootAttribute","clearAttributes","getRoot","setAttributes","change","L","editableElements","toolbarElement","setData"],"sources":["webpack://CKEditor/webpack/universalModuleDefinition","webpack://CKEditor/external umd \"@ckeditor/ckeditor5-watchdog\"","webpack://CKEditor/external umd \"prop-types\"","webpack://CKEditor/external umd \"react\"","webpack://CKEditor/webpack/bootstrap","webpack://CKEditor/webpack/runtime/compat get default export","webpack://CKEditor/webpack/runtime/define property getters","webpack://CKEditor/webpack/runtime/hasOwnProperty shorthand","webpack://CKEditor/webpack/runtime/make namespace object","webpack://CKEditor/node_modules/@ckeditor/ckeditor5-utils/src/uid.js","webpack://CKEditor/src/ckeditorcontext.tsx","webpack://CKEditor/src/lifecycle/LifeCycleElementSemaphore.ts","webpack://CKEditor/src/utils/once.ts","webpack://CKEditor/src/utils/defer.ts","webpack://CKEditor/src/ckeditor.tsx","webpack://CKEditor/src/utils/mergeRefs.ts","webpack://CKEditor/src/utils/overwriteObject.ts","webpack://CKEditor/src/hooks/useRefSafeCallback.ts","webpack://CKEditor/src/utils/overwriteArray.ts","webpack://CKEditor/src/utils/shallowCompareArrays.ts","webpack://CKEditor/src/hooks/useInstantEditorEffect.ts","webpack://CKEditor/src/hooks/useInstantEffect.ts","webpack://CKEditor/src/useMultiRootEditor.tsx","webpack://CKEditor/src/lifecycle/useLifeCycleSemaphoreSyncRef.tsx","webpack://CKEditor/src/utils/uniq.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"prop-types\"), require(\"@ckeditor/ckeditor5-watchdog\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"prop-types\", \"@ckeditor/ckeditor5-watchdog\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CKEditor\"] = factory(require(\"react\"), require(\"prop-types\"), require(\"@ckeditor/ckeditor5-watchdog\"));\n\telse\n\t\troot[\"CKEditor\"] = factory(root[\"react\"], root[\"prop-types\"], root[\"@ckeditor/ckeditor5-watchdog\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__155__, __WEBPACK_EXTERNAL_MODULE__949__, __WEBPACK_EXTERNAL_MODULE__546__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__546__;","module.exports = __WEBPACK_EXTERNAL_MODULE__949__;","module.exports = __WEBPACK_EXTERNAL_MODULE__155__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/uid\n */\n/**\n * A hash table of hex numbers to avoid using toString() in uid() which is costly.\n * [ '00', '01', '02', ..., 'fe', 'ff' ]\n */\nconst HEX_NUMBERS = new Array(256).fill('')\n    .map((_, index) => ('0' + (index).toString(16)).slice(-2));\n/**\n * Returns a unique id. The id starts with an \"e\" character and a randomly generated string of\n * 32 alphanumeric characters.\n *\n * **Note**: The characters the unique id is built from correspond to the hex number notation\n * (from \"0\" to \"9\", from \"a\" to \"f\"). In other words, each id corresponds to an \"e\" followed\n * by 16 8-bit numbers next to each other.\n *\n * @returns An unique id string.\n */\nexport default function uid() {\n    // Let's create some positive random 32bit integers first.\n    //\n    // 1. Math.random() is a float between 0 and 1.\n    // 2. 0x100000000 is 2^32 = 4294967296.\n    // 3. >>> 0 enforces integer (in JS all numbers are floating point).\n    //\n    // For instance:\n    //\t\tMath.random() * 0x100000000 = 3366450031.853859\n    // but\n    //\t\tMath.random() * 0x100000000 >>> 0 = 3366450031.\n    const r1 = Math.random() * 0x100000000 >>> 0;\n    const r2 = Math.random() * 0x100000000 >>> 0;\n    const r3 = Math.random() * 0x100000000 >>> 0;\n    const r4 = Math.random() * 0x100000000 >>> 0;\n    // Make sure that id does not start with number.\n    return 'e' +\n        HEX_NUMBERS[r1 >> 0 & 0xFF] +\n        HEX_NUMBERS[r1 >> 8 & 0xFF] +\n        HEX_NUMBERS[r1 >> 16 & 0xFF] +\n        HEX_NUMBERS[r1 >> 24 & 0xFF] +\n        HEX_NUMBERS[r2 >> 0 & 0xFF] +\n        HEX_NUMBERS[r2 >> 8 & 0xFF] +\n        HEX_NUMBERS[r2 >> 16 & 0xFF] +\n        HEX_NUMBERS[r2 >> 24 & 0xFF] +\n        HEX_NUMBERS[r3 >> 0 & 0xFF] +\n        HEX_NUMBERS[r3 >> 8 & 0xFF] +\n        HEX_NUMBERS[r3 >> 16 & 0xFF] +\n        HEX_NUMBERS[r3 >> 24 & 0xFF] +\n        HEX_NUMBERS[r4 >> 0 & 0xFF] +\n        HEX_NUMBERS[r4 >> 8 & 0xFF] +\n        HEX_NUMBERS[r4 >> 16 & 0xFF] +\n        HEX_NUMBERS[r4 >> 24 & 0xFF];\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport React, { type ReactNode } from 'react';\nimport PropTypes, { type InferProps, type Validator } from 'prop-types';\n\nimport { ContextWatchdog } from '@ckeditor/ckeditor5-watchdog';\nimport type { WatchdogConfig } from '@ckeditor/ckeditor5-watchdog/src/watchdog';\n\nimport type { Context, ContextConfig } from '@ckeditor/ckeditor5-core';\n\nexport const ContextWatchdogContext = React.createContext<ContextWatchdog | 'contextWatchdog' | null>( 'contextWatchdog' );\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default class CKEditorContext<TContext extends Context = Context> extends React.Component<Props<TContext>, {}> {\n\tpublic contextWatchdog: ContextWatchdog<TContext> | null = null;\n\n\tconstructor( props: Props<TContext>, context: any ) {\n\t\tsuper( props, context );\n\n\t\tif ( this.props.isLayoutReady ) {\n\t\t\tthis._initializeContextWatchdog( this.props.config );\n\t\t}\n\t}\n\n\tpublic override shouldComponentUpdate( nextProps: Readonly<Props<TContext> & { children?: ReactNode | undefined }> ): boolean {\n\t\treturn this._shouldComponentUpdate( nextProps ) as unknown as boolean;\n\t}\n\n\t/**\n\t * Wrapper for the async handler. Note that this is an implementation bug, see https://github.com/ckeditor/ckeditor5-react/issues/312.\n\t */\n\tprivate async _shouldComponentUpdate( nextProps: Readonly<Props<TContext> & { children?: ReactNode | undefined }> ): Promise<boolean> {\n\t\t// If the configuration changes then the ContextWatchdog needs to be destroyed and recreated\n\t\t// On top of the new configuration.\n\t\tif ( nextProps.id !== this.props.id ) {\n\t\t\t/* istanbul ignore else */\n\t\t\tif ( this.contextWatchdog ) {\n\t\t\t\tawait this.contextWatchdog.destroy();\n\t\t\t}\n\n\t\t\tawait this._initializeContextWatchdog( nextProps.config );\n\t\t}\n\n\t\tif ( nextProps.isLayoutReady && !this.contextWatchdog ) {\n\t\t\tawait this._initializeContextWatchdog( nextProps.config );\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Rerender the component only when children has changed.\n\t\treturn this.props.children !== nextProps.children;\n\t}\n\n\tpublic override render(): ReactNode {\n\t\treturn (\n\t\t\t<ContextWatchdogContext.Provider value={ this.contextWatchdog }>\n\t\t\t\t{ this.props.children }\n\t\t\t</ContextWatchdogContext.Provider>\n\t\t);\n\t}\n\n\tpublic override componentWillUnmount(): void {\n\t\tthis._destroyContext();\n\t}\n\n\tprivate async _initializeContextWatchdog( config?: ContextConfig ): Promise<void> {\n\t\tthis.contextWatchdog = new ContextWatchdog( this.props.context!, this.props.watchdogConfig );\n\n\t\tthis.contextWatchdog.on( 'error', ( _, errorEvent ) => {\n\t\t\tthis.props.onError( errorEvent.error, {\n\t\t\t\tphase: 'runtime',\n\t\t\t\twillContextRestart: errorEvent.causesRestart\n\t\t\t} );\n\t\t} );\n\n\t\tthis.contextWatchdog.on( 'stateChange', () => {\n\t\t\tif ( this.contextWatchdog!.state === 'ready' && this.props.onReady ) {\n\t\t\t\tthis.props.onReady( this.contextWatchdog!.context! );\n\t\t\t}\n\t\t} );\n\n\t\tawait this.contextWatchdog.create( config )\n\t\t\t.catch( error => {\n\t\t\t\tthis.props.onError( error, {\n\t\t\t\t\tphase: 'initialization',\n\t\t\t\t\twillContextRestart: false\n\t\t\t\t} );\n\t\t\t} );\n\t}\n\n\tprivate async _destroyContext(): Promise<void> {\n\t\tif ( this.contextWatchdog ) {\n\t\t\tawait this.contextWatchdog.destroy();\n\t\t\tthis.contextWatchdog = null;\n\t\t}\n\t}\n\n\tpublic static defaultProps: Partial<Props<Context>> = {\n\t\tisLayoutReady: true,\n\t\tonError: ( error, details ) => console.error( error, details )\n\t};\n\n\tpublic static propTypes = {\n\t\tid: PropTypes.string,\n\t\tisLayoutReady: PropTypes.bool,\n\t\tcontext: PropTypes.func as unknown as Validator<{ create( ...args: any ): Promise<any> } | undefined>,\n\t\twatchdogConfig: PropTypes.object,\n\t\tconfig: PropTypes.object,\n\t\tonReady: PropTypes.func,\n\t\tonError: PropTypes.func\n\t};\n}\n\ninterface Props<TContext extends Context> extends InferProps<typeof CKEditorContext.propTypes> {\n\tcontext?: { create( ...args: any ): Promise<TContext> };\n\twatchdogConfig?: WatchdogConfig;\n\tconfig?: ContextConfig;\n\tonReady?: ( context: Context ) => void; // TODO this should accept TContext (after ContextWatchdog release).\n\tonError: ( error: Error, details: ErrorDetails ) => void;\n\tchildren?: ReactNode;\n}\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillContextRestart: boolean;\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { createDefer, type Defer } from '../utils/defer';\nimport { once } from '../utils/once';\n\n/**\n * This class is utilized to pause the initialization of an editor when another instance is already present on a specified element.\n * It is engineered to address the following issues:\n *\n *\t* Rapid changes in component properties often lead to the re-initialization of the editor, which can trigger\n *\t  the `editor-source-element-already-used` exception. This occurs because the editor is still in the process of initializing\n *\t  when the component decides to destroy it. This semaphore waits for the editor to fully initialize before destroying it, thereby\n *\t  allowing a new instance of the editor to be attached to the specified element.\n *\n *\t* Rapid mounting and unmounting in strict mode frequently results in the `editor-source-element-already-used` exception\n *\t  being thrown by the editor. This is due to React reusing the underlying DOM element during the mounting and unmounting of components\n *\t  (especially if the same component is being mounted and unmounted). Consequently, a race condition arises. The first render begins to\n *\t  attach the editor (in async mode), and shortly thereafter, it is destroyed and a new instance of the component is initialized.\n *\t  This semaphore, by utilizing a static semaphores promises map, retains information about whether the element is used by a previous\n *\t  instance of the editor and resumes execution when it is freed.\n *\n *\t* The process involves starting up many editors that are no longer needed and are immediately removed in the following rerenders.\n *\t  This can cause the editor’s initialization performance to slow down. The initialization of the editor is skipped when numerous\n *\t  rerenders occur within a short time-frame while using this semaphore. An example of this could be a situation with 4 rerenders\n *\t  occurring within a 10ms period. This semaphore will likely batch these calls, and instead of initializing 4 editors, only 2 will be\n *\t  initialized (the first and the last one).\n */\nexport class LifeCycleElementSemaphore<R> {\n\t/**\n\t * This is a map of elements associated with promises. It informs the semaphore that the underlying HTML element, used as a key,\n\t * is currently in use by another editor. Each element is assigned a promise, which allows for the easy chaining of new\n\t * editor instances on an element that is already in use by another instance. The process works as follows:\n\t *\n\t * \t1. If an element is being used by an editor, then the initialization of a new editor\n\t * \t   instance is chained using the `.then()` method of the Promise.\n\t *\n\t * \t2. If the editor associated with the underlying element is destroyed, then `Promise.resolve()` is called\n\t * \t   and the previously assigned `.then()` editor callback is executed.\n\t *\n\t *  @see {@link #lock} for more detailed information on the implementation.\n\t */\n\tprivate static readonly _semaphores = new Map<HTMLElement, Promise<void>>();\n\n\t/**\n\t * This should define async methods for initializing and destroying the editor.\n\t * Essentially, it's an async version of basic React lifecycle methods like `componentDidMount`, `componentWillUnmount`.\n\t *\n\t * \t* Result of {@link LifeCycleAsyncOperators#mount} method is passed to {@link LifeCycleAsyncOperators#unmount} as an argument.\n\t */\n\tprivate readonly _lifecycle: LifeCycleAsyncOperators<R>;\n\n\t/**\n\t * This is the element instance that the editor uses for mounting. This element should contain the `ckeditorInstance` member\n\t * once the editor has been successfully mounted to it. The semaphore ensures that a new instance of the editor, which will\n\t * be assigned to this element by the {@link #_lifecycle:mount} method, will always be initialized after the successful\n\t * destruction of the underlying `ckeditorInstance` that was previously mounted on this element.\n\t */\n\tprivate readonly _element: HTMLElement;\n\n\t/**\n\t * This is the lock mechanism utilized by the {@link #lock} and {@link #release} methods.\n\t *\n\t * \t* If the editor is not yet mounted and is awaiting mounting (for instance, when another editor is\n\t * \t  occupying the element), then it is null.\n\t *\n\t * \t* When the editor is mounted on the element, this variable holds an unresolved promise that will be\n\t * \t  resolved after the editor is destroyed.\n\t *\n\t * \t* Once the editor is destroyed (and it was previously mounted), the promise is resolved.\n\t */\n\tprivate _releaseLock: Defer<void> | null = null;\n\n\t/**\n\t * This is the result of the {@link #_lifecycle:mount} function. This value should be reset to `null`\n\t * once the semaphore is released. It is utilized to store certain data that must be removed following\n\t * the destruction of the editor. This data may include the editor's instance, the assigned watchdog,\n\t * or handles for additional window listeners.\n\t */\n\tprivate _value: R | null = null;\n\n\t/**\n\t * This is a list of callbacks that are triggered if the semaphore {@link #_lifecycle:mount} method executes successfully.\n\t * It is utilized in scenarios where we need to assign certain properties to an editor that is currently in the process of mounting.\n\t * An instance of such usage could be two-way binding. We aim to prevent the loss of all `setData` calls if the editor has not\n\t * yet been mounted, therefore these calls will be executed immediately following the completion of the mounting process.\n\t */\n\tprivate _afterMountCallbacks: Array<LifeCycleAfterMountCallback<R>> = [];\n\n\t/**\n\t * This represents the actual mounting state of the semaphore. It is primarily used by the {@link #release} method to\n\t * determine whether the initialization of the editor should be skipped or, if the editor is already initialized, the editor\n\t * should be destroyed.\n\t *\n\t * \t* If `destroyedBeforeInitialization` is true, then the {@link #release} method was invoked before the editor began to mount.\n\t * \t  This often occurs in strict mode when we assign a promise to the {@link LifeCycleEditorElementSemaphore#_semaphores} map\n\t * \t  and the assigned `mount` callback has not yet been called. In this scenario, it is safe to skip the initialization of the editor\n\t * \t  and simply release the semaphore.\n\t *\n\t *\t* If `mountingInProgress` is a Promise, then the {@link #release} method was invoked after the initialization of the editor and\n\t \t  the editor must be destroyed before the semaphore is released.\n\t*/\n\tprivate _state: LifeCycleState<R> = {\n\t\tdestroyedBeforeInitialization: false,\n\t\tmountingInProgress: null\n\t};\n\n\tconstructor( element: HTMLElement, lifecycle: LifeCycleAsyncOperators<R> ) {\n\t\tthis._element = element;\n\t\tthis._lifecycle = lifecycle;\n\t\tthis._lock();\n\t}\n\n\t/**\n\t * Getter for {@link #_value}.\n\t */\n\tpublic get value(): R | null {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * Occasionally, the Watchdog restarts the editor instance, resulting in a new instance being assigned to the semaphore.\n\t * In terms of race conditions, it's generally safer to simply override the semaphore value rather than recreating it\n\t * with a different one.\n\t */\n\tpublic unsafeSetValue( value: R ): void {\n\t\tthis._value = value;\n\n\t\tthis._afterMountCallbacks.forEach( callback => callback( value ) );\n\t\tthis._afterMountCallbacks = [];\n\t}\n\n\t/**\n\t * This registers a callback that will be triggered after the editor has been successfully mounted.\n\t *\n\t * \t* If the editor is already mounted, the callback will be executed immediately.\n\t *\t* If the editor is in the process of mounting, the callback will be executed upon successful mounting.\n\t* \t* If the editor is never mounted, the passed callback will not be executed.\n\t* \t* If an exception is thrown within the callback, it will be re-thrown in the semaphore.\n\t*/\n\tpublic runAfterMount( callback: LifeCycleAfterMountCallback<R> ): void {\n\t\tconst { _value, _afterMountCallbacks } = this;\n\n\t\tif ( _value ) {\n\t\t\tcallback( _value );\n\t\t} else {\n\t\t\t_afterMountCallbacks.push( callback );\n\t\t}\n\t}\n\n\t/**\n\t * This method is used to inform other components that the {@link #_element} will be used by the editor,\n\t * which is initialized by the {@link #_lifecycle} methods.\n\t *\n\t * \t* If an editor is already present on the provided element, the initialization of the current one\n\t * \t  will be postponed until the previous one is destroyed.\n\t *\n\t * \t* If the element is empty and does not have an editor attached to it, the currently locked editor will\n\t * \t  be mounted immediately.\n\t *\n\t * After the successful initialization of the editor and the assignment of the {@link #_value} member,\n\t * the `onReady` lifecycle method is called.\n\t *\n\t * *Important note:*\n\t *\n\t * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n\t * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tprivate _lock(): void {\n\t\tconst { _semaphores } = LifeCycleElementSemaphore;\n\t\tconst { _state, _element, _lifecycle } = this;\n\n\t\t// This promise signifies that the previous editor is still attached to the current element.\n\t\t// Upon successful resolution, it will indicate that it is safe to assume that the element has\n\t\t// no assigned editor instance and can be reinitialized.\n\t\tconst prevElementSemaphore = _semaphores.get( _element ) || Promise.resolve( null );\n\n\t\t// This is a lock that will be resolved after the `release` method is called. Due to this lock,\n\t\t// the promise will never be resolved until the editor is destroyed.\n\t\tconst releaseLock = createDefer();\n\t\tthis._releaseLock = releaseLock;\n\n\t\t// This is the initialization of the editor that occurs after the previous editor has been detached from the specified element.\n\t\t//\n\t\t// If the `release` method was called before the initialization of the current editor instance, then it will be skipped.\n\t\t// This situation occurs quite frequently when we have three or more rerenders in a row, and it doesn't make sense to initialize\n\t\t// the second editor because it will be overridden anyway by the third one.\n\t\tconst newElementSemaphore = prevElementSemaphore\n\t\t\t.then( () => {\n\t\t\t\tif ( _state.destroyedBeforeInitialization ) {\n\t\t\t\t\treturn Promise.resolve( undefined );\n\t\t\t\t}\n\n\t\t\t\t// This variable will be used later in the `release` method to determine\n\t\t\t\t// whether the editor is being destroyed prior to initialization.\n\t\t\t\t_state.mountingInProgress = _lifecycle.mount().then( mountResult => {\n\t\t\t\t\tif ( mountResult ) {\n\t\t\t\t\t\tthis.unsafeSetValue( mountResult );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn mountResult;\n\t\t\t\t} );\n\n\t\t\t\treturn _state.mountingInProgress;\n\t\t\t} )\n\t\t\t.then( async mountResult => {\n\t\t\t\t// Everything is fine, all ready callback might be fired here.\n\t\t\t\tif ( mountResult && _lifecycle.afterMount ) {\n\t\t\t\t\tawait _lifecycle.afterMount( {\n\t\t\t\t\t\telement: _element,\n\t\t\t\t\t\tmountResult\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} )\n\n\t\t\t// It will be released after destroying of editor by the {@link #_release method}.\n\t\t\t.then( () => releaseLock.promise )\n\n\t\t\t// Prevent hanging of semaphore during mount, just assume that everything is fine\n\t\t\t.catch( error => {\n\t\t\t\tconsole.error( 'Semaphore mounting error:', error );\n\t\t\t} )\n\n\t\t\t// Remove semaphore from map if released.\n\t\t\t.then( () => {\n\t\t\t\tif ( _semaphores.get( _element ) === newElementSemaphore ) {\n\t\t\t\t\t_semaphores.delete( _element );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t_semaphores.set( _element, newElementSemaphore );\n\t}\n\n\t/**\n\t * Inverse of {@link #_lock} method that tries to destroy attached editor.\n\t *\n\t * \t* If editor is being already attached to element (or is in attaching process) then after fully initialization of editor\n\t * \t  destroy is performed and semaphore is released. The {@link #_lifecycle} unmount method is called.\n\t *\n\t * \t* If editor is being destroyed before initialization then it does nothing but sets `destroyedBeforeInitialization` flag that\n\t * \t  will be later checked by {@link #_lock} method in initialization. The {@link #_lifecycle} unmount method is not called.\n\t *\n\t * *Important note:*\n\t *\n\t * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n\t * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tpublic readonly release = once( () => {\n\t\tconst { _releaseLock, _state, _element, _lifecycle } = this;\n\n\t\tif ( _state.mountingInProgress ) {\n\t\t\t_state.mountingInProgress\n\t\t\t\t.then( () => _lifecycle.unmount( {\n\t\t\t\t\telement: _element,\n\n\t\t\t\t\t// Mount result might be overridden by watchdog during restart so use instance variable.\n\t\t\t\t\tmountResult: this.value!\n\t\t\t\t} ) )\n\n\t\t\t\t// Prevent hanging of semaphore during unmount, just assume that everything is fine\n\t\t\t\t.catch( error => {\n\t\t\t\t\tconsole.error( 'Semaphore unmounting error:', error );\n\t\t\t\t} )\n\n\t\t\t\t.then( _releaseLock!.resolve )\n\t\t\t\t.then( () => {\n\t\t\t\t\tthis._value = null;\n\t\t\t\t} );\n\t\t} else {\n\t\t\t_state.destroyedBeforeInitialization = true;\n\t\t\t_releaseLock!.resolve();\n\t\t}\n\t} );\n}\n\nexport type LifeCycleAfterMountCallback<R> = ( mountResult: R ) => void;\n\ntype LifeCycleState<R> = {\n\tdestroyedBeforeInitialization: boolean;\n\tmountingInProgress: Promise<R> | null;\n};\n\ntype LifeCyclePostMountAttrs<R> = {\n\telement: HTMLElement;\n\tmountResult: R;\n};\n\ntype LifeCycleAsyncOperators<R> = {\n\tmount: () => Promise<R>;\n\tafterMount?: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void> | void;\n\tunmount: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void>;\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Ensures that passed function will be executed only once.\n */\nexport function once<A extends Array<any>, R = void>( fn: ( ...args: A ) => R ): ( ...args: A ) => R {\n\tlet lastResult: { current: R } | null = null;\n\n\treturn ( ...args: A ): R => {\n\t\tif ( !lastResult ) {\n\t\t\tlastResult = {\n\t\t\t\tcurrent: fn( ...args )\n\t\t\t};\n\t\t}\n\n\t\treturn lastResult.current;\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nexport type Defer<E> = {\n\tpromise: Promise<E>;\n\tresolve: ( value: E ) => void;\n};\n\n/**\n * This function generates a promise that can be resolved by invoking the returned `resolve` method.\n * It proves to be beneficial in the creation of various types of locks and semaphores.\n */\nexport function createDefer<E = void>(): Defer<E> {\n\tconst deferred: Defer<E> = {\n\t\tresolve: null as any,\n\t\tpromise: null as any\n\t};\n\n\tdeferred.promise = new Promise<E>( resolve => {\n\t\tdeferred.resolve = resolve;\n\t} );\n\n\treturn deferred;\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals window */\n\nimport React from 'react';\nimport PropTypes, { type InferProps, type Validator } from 'prop-types';\n\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\n\nimport type { EventInfo } from '@ckeditor/ckeditor5-utils';\nimport type { Editor, EditorConfig } from '@ckeditor/ckeditor5-core';\nimport type { DocumentChangeEvent } from '@ckeditor/ckeditor5-engine';\n\nimport { EditorWatchdog, ContextWatchdog } from '@ckeditor/ckeditor5-watchdog';\nimport type { WatchdogConfig } from '@ckeditor/ckeditor5-watchdog/src/watchdog';\nimport type { EditorCreatorFunction } from '@ckeditor/ckeditor5-watchdog/src/editorwatchdog';\n\nimport { ContextWatchdogContext } from './ckeditorcontext';\n\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default class CKEditor<TEditor extends Editor> extends React.Component<Props<TEditor>> {\n\t/**\n\t * After mounting the editor, the variable will contain a reference to the created editor.\n\t * @see: https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html\n\t */\n\tprivate domContainer = React.createRef<HTMLDivElement>();\n\n\t/**\n\t * Unlocks element in editor semaphore after destroy editor instance.\n\t */\n\tprivate editorSemaphore: LifeCycleElementSemaphore<EditorSemaphoreMountResult<TEditor>> | null = null;\n\n\tconstructor( props: Props<TEditor> ) {\n\t\tsuper( props );\n\n\t\tconst { CKEDITOR_VERSION } = window;\n\n\t\tif ( CKEDITOR_VERSION ) {\n\t\t\tconst [ major ] = CKEDITOR_VERSION.split( '.' ).map( Number );\n\n\t\t\tif ( major < 37 ) {\n\t\t\t\tconsole.warn( 'The <CKEditor> component requires using CKEditor 5 in version 37 or higher.' );\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn( 'Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.' );\n\t\t}\n\t}\n\n\tprivate get _semaphoreValue(): EditorSemaphoreMountResult<TEditor> | null {\n\t\tconst { editorSemaphore } = this;\n\n\t\treturn editorSemaphore ? editorSemaphore.value : null;\n\t}\n\n\t/**\n\t * An watchdog instance.\n\t */\n\tpublic get watchdog(): EditorWatchdog<TEditor> | EditorWatchdogAdapter<TEditor> | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.watchdog : null;\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): Editor | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.instance : null;\n\t}\n\n\t/**\n\t * The CKEditor component should not be updated by React itself.\n\t * However, if the component identifier changes, the whole structure should be created once again.\n\t */\n\tpublic override shouldComponentUpdate( nextProps: Readonly<Props<TEditor>> ): boolean {\n\t\tconst { props, editorSemaphore } = this;\n\n\t\t// Only when the component identifier changes the whole structure should be re-created once again.\n\t\tif ( nextProps.id !== props.id ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nextProps.disableWatchdog !== props.disableWatchdog ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( editorSemaphore ) {\n\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\tif ( this._shouldUpdateEditorData( props, nextProps, instance ) ) {\n\t\t\t\t\tinstance.data.set( nextProps.data! );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tif ( 'disabled' in nextProps ) {\n\t\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\t\tif ( nextProps.disabled ) {\n\t\t\t\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Initialize the editor when the component is mounted.\n\t */\n\tpublic override componentDidMount(): void {\n\t\tthis._initLifeCycleSemaphore();\n\t}\n\n\t/**\n\t * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.\n\t */\n\tpublic override componentDidUpdate(): void {\n\t\tthis._initLifeCycleSemaphore();\n\t}\n\n\t/**\n\t * Destroy the editor before unmounting the component.\n\t */\n\tpublic override componentWillUnmount(): void {\n\t\tthis._unlockLifeCycleSemaphore();\n\t}\n\n\t/**\n\t * Async destroy attached editor and unlock element semaphore.\n\t */\n\tprivate _unlockLifeCycleSemaphore() {\n\t\tif ( this.editorSemaphore ) {\n\t\t\tthis.editorSemaphore.release();\n\t\t\tthis.editorSemaphore = null;\n\t\t}\n\t}\n\n\t/**\n\t * Unlocks previous editor semaphore and creates new one..\n\t */\n\tprivate _initLifeCycleSemaphore() {\n\t\tthis._unlockLifeCycleSemaphore();\n\t\tthis.editorSemaphore = new LifeCycleElementSemaphore( this.domContainer.current!, {\n\t\t\tmount: async () => this._initializeEditor(),\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = this.props;\n\n\t\t\t\tif ( onReady && this.domContainer.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait this._destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Render a <div> element which will be replaced by CKEditor.\n\t */\n\tpublic override render(): React.ReactNode {\n\t\treturn (\n\t\t\t<div ref={ this.domContainer }></div>\n\t\t);\n\t}\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tprivate async _initializeEditor(): Promise<EditorSemaphoreMountResult<TEditor>> {\n\t\tif ( this.props.disableWatchdog ) {\n\t\t\tconst instance = await this._createEditor( this.domContainer.current!, this._getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as TEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\tif ( this.context instanceof ContextWatchdog ) {\n\t\t\t\treturn new EditorWatchdogAdapter( this.context );\n\t\t\t}\n\n\t\t\treturn new CKEditor._EditorWatchdog( this.props.editor, this.props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<TEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\twatchdog.setCreator( async ( el, config ) => {\n\t\t\tconst { editorSemaphore } = this;\n\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\tif ( totalRestartsRef.current > 0 &&\n\t\t\t\t\tonAfterDestroy &&\n\t\t\t\t\teditorSemaphore &&\n\t\t\t\t\teditorSemaphore.value &&\n\t\t\t\t\teditorSemaphore.value.instance ) {\n\t\t\t\tonAfterDestroy( editorSemaphore.value.instance );\n\t\t\t}\n\n\t\t\tconst instance = await this._createEditor( el as any, config );\n\n\t\t\tif ( totalRestartsRef.current > 0 ) {\n\t\t\t\teditorSemaphore!.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\tif ( this.props.onReady ) {\n\t\t\t\t\t\tthis.props.onReady( watchdog!.editor as TEditor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = this.props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog\n\t\t\t.create( this.domContainer.current!, this._getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = this.props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t} );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t}\n\n\t/**\n\t * Creates an editor from the element and configuration.\n\t *\n\t * @param element The source element.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tprivate _createEditor( element: HTMLElement | string | Record<string, string>, config: EditorConfig ): Promise<TEditor> {\n\t\treturn this.props.editor.create( element as HTMLElement, config )\n\t\t\t.then( editor => {\n\t\t\t\tif ( 'disabled' in this.props ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.disabled ) {\n\t\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.onChange ) {\n\t\t\t\t\t\tthis.props.onChange( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.onFocus ) {\n\t\t\t\t\t\tthis.props.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.onBlur ) {\n\t\t\t\t\t\tthis.props.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t}\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tprivate async _destroyEditor( initializeResult: EditorSemaphoreMountResult<Editor> ): Promise<void> {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns true when the editor should be updated.\n\t *\n\t * @param prevProps Previous react's properties.\n\t * @param nextProps React's properties.\n\t * @param editor Current editor instance.\n\t */\n\tprivate _shouldUpdateEditorData( prevProps: Readonly<Props<TEditor>>, nextProps: Readonly<Props<TEditor>>, editor: TEditor ): boolean {\n\t\t// Check whether `nextProps.data` is equal to `this.props.data` is required if somebody defined the `#data`\n\t\t// property as a static string and updated a state of component when the editor's content has been changed.\n\t\t// If we avoid checking those properties, the editor's content will back to the initial value because\n\t\t// the state has been changed and React will call this method.\n\t\tif ( prevProps.data === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We should not change data if the editor's content is equal to the `#data` property.\n\t\tif ( editor.data.get() === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tprivate _getConfig(): EditorConfig {\n\t\tconst config = this.props.config || {};\n\n\t\tif ( this.props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `content` property. ' +\n\t\t\t\t'The config value takes precedence over `content` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\t// Merge two possible ways of providing data into the `config.initialData` field.\n\t\treturn {\n\t\t\t...config,\n\t\t\tinitialData: config.initialData || this.props.data || ''\n\t\t};\n\t}\n\n\tpublic static override contextType = ContextWatchdogContext;\n\n\t// Properties definition.\n\tpublic static propTypes = {\n\t\teditor: PropTypes.func.isRequired as unknown as Validator<{ create( ...args: any ): Promise<any> }>,\n\t\tdata: PropTypes.string,\n\t\tconfig: PropTypes.object,\n\t\tdisableWatchdog: PropTypes.bool,\n\t\twatchdogConfig: PropTypes.object,\n\t\tonChange: PropTypes.func,\n\t\tonReady: PropTypes.func,\n\t\tonFocus: PropTypes.func,\n\t\tonBlur: PropTypes.func,\n\t\tonError: PropTypes.func,\n\t\tdisabled: PropTypes.bool,\n\t\tid: PropTypes.any\n\t};\n\n\t// Store the API in the static property to easily overwrite it in tests.\n\t// Too bad dependency injection does not work in Webpack + ES 6 (const) + Babel.\n\tpublic static _EditorWatchdog = EditorWatchdog;\n}\n\n/**\n * TODO this is type space definition for props, the CKEditor.propTypes is a run-time props validation that should match.\n */\ninterface Props<TEditor extends Editor> extends InferProps<typeof CKEditor.propTypes> {\n\teditor: { create( ...args: any ): Promise<TEditor> };\n\tconfig?: EditorConfig;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tonReady?: ( editor: TEditor ) => void;\n\tonAfterDestroy?: ( editor: TEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: TEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: TEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: TEditor ) => void;\n}\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\n/**\n * An adapter aligning the context watchdog API to the editor watchdog API for easier usage.\n */\nexport class EditorWatchdogAdapter<TEditor extends Editor> {\n\t/**\n\t * The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tprivate readonly _contextWatchdog: ContextWatchdog;\n\n\t/**\n\t * A unique id for the adapter to distinguish editor items when using the context watchdog API.\n\t */\n\tprivate readonly _id: string;\n\n\t/**\n\t * A watchdog's editor creator function.\n\t */\n\tprivate _creator?: EditorCreatorFunction;\n\n\t/**\n\t * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tconstructor( contextWatchdog: ContextWatchdog ) {\n\t\tthis._contextWatchdog = contextWatchdog;\n\t\tthis._id = uid();\n\t}\n\n\t/**\n\t *  @param creator A watchdog's editor creator function.\n\t */\n\tpublic setCreator( creator: EditorCreatorFunction ): void {\n\t\tthis._creator = creator;\n\t}\n\n\t/**\n\t * Adds an editor configuration to the context watchdog registry. Creates an instance of it.\n\t *\n\t * @param sourceElementOrData A source element or data for the new editor.\n\t * @param config CKEditor 5 editor config.\n\t */\n\tpublic create( sourceElementOrData: HTMLElement | string, config: EditorConfig ): Promise<unknown> {\n\t\treturn this._contextWatchdog.add( {\n\t\t\tsourceElementOrData,\n\t\t\tconfig,\n\t\t\tcreator: this._creator!,\n\t\t\tid: this._id,\n\t\t\ttype: 'editor'\n\t\t} );\n\t}\n\n\t/**\n\t * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.\n\t * Currently works only for the `error` event.\n\t */\n\tpublic on( _: string, callback: ( _: null, data: { error: Error; causesRestart?: boolean } ) => void ): void {\n\t\t// Assume that the event name was error.\n\t\tthis._contextWatchdog.on( 'itemError', ( _, { itemId, error } ) => {\n\t\t\tif ( itemId === this._id ) {\n\t\t\t\tcallback( null, { error, causesRestart: undefined } );\n\t\t\t}\n\t\t} );\n\t}\n\n\tpublic destroy(): Promise<unknown> {\n\t\t// Destroying an editor instance after destroying the Context is handled in the `ContextWatchdog` class.\n\t\t// As `EditorWatchdogAdapter` is an adapter, we should not destroy the editor manually.\n\t\t// Otherwise, it causes that the editor is destroyed twice. However, there is a case, when the editor\n\t\t// needs to be removed from the context, without destroying the context itself. We may assume the following\n\t\t// relations with `ContextWatchdog#state`:\n\t\t//\n\t\t// a) `ContextWatchdog#state` === 'ready' - context is not destroyed; it's safe to destroy the editor manually.\n\t\t// b) `ContextWatchdog#state` === 'destroyed' - context is destroyed; let `ContextWatchdog` handle the whole process.\n\t\t//\n\t\t// See #354 for more information.\n\t\tif ( this._contextWatchdog.state === 'ready' ) {\n\t\t\treturn this._contextWatchdog.remove( this._id );\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): TEditor {\n\t\treturn this._contextWatchdog.getItem( this._id ) as TEditor;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport type { MutableRefObject } from 'react';\n\ntype CallbackRef<T> = ( element: T ) => void;\n\ntype ReactRef<T> = CallbackRef<T | null> | MutableRefObject<T | null> | null;\n\n/**\n * Combine multiple react refs into one.\n */\nexport function mergeRefs<T>( ...refs: Array<ReactRef<T>> ): CallbackRef<T> {\n\treturn value => {\n\t\trefs.forEach( ref => {\n\t\t\tif ( typeof ref === 'function' ) {\n\t\t\t\tref( value );\n\t\t\t} else if ( ref != null ) {\n\t\t\t\tref.current = value;\n\t\t\t}\n\t\t} );\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Clears whole object while keeping its reference.\n */\nexport function overwriteObject<O extends Record<string, any>>( source: O, destination: O ): O {\n\tfor ( const prop of Object.getOwnPropertyNames( destination ) ) {\n\t\tdelete destination[ prop ];\n\t}\n\n\t// Prevent assigning self referencing attributes which crashes `Object.assign`.\n\tfor ( const [ key, value ] of Object.entries( source ) ) {\n\t\tif ( value !== destination && key !== 'prototype' && key !== '__proto__' ) {\n\t\t\t( destination as any )[ key ] = value;\n\t\t}\n\t}\n\n\treturn destination;\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { useCallback, useRef } from 'react';\n\n/**\n * Hook that guarantees that returns constant reference for passed function.\n * Useful for preventing closures from capturing cached scope variables (avoiding the stale closure problem).\n */\nexport const useRefSafeCallback = <A extends Array<unknown>, R>( fn: ( ...args: A ) => R ): typeof fn => {\n\tconst callbackRef = useRef<typeof fn>();\n\tcallbackRef.current = fn;\n\n\treturn useCallback(\n\t\t( ...args: A ): R => ( callbackRef.current as typeof fn )( ...args ),\n\t\t[]\n\t);\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Clear whole array while keeping its reference.\n */\nexport function overwriteArray<A extends Array<any>>( source: A, destination: A ): A {\n\tdestination.length = 0;\n\tdestination.push( ...source );\n\n\treturn destination;\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Shallow comparison of two arrays.\n */\nexport const shallowCompareArrays = <T>(\n\ta: Readonly<Array<T>>,\n\tb: Readonly<Array<T>>\n): boolean => {\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\tif ( !a || !b ) {\n\t\treturn false;\n\t}\n\n\tfor ( let i = 0; i < a.length; ++i ) {\n\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport type { DependencyList } from 'react';\nimport type { LifeCycleElementSemaphore } from '../lifecycle/LifeCycleElementSemaphore';\nimport { useInstantEffect } from './useInstantEffect';\n\n/**\n * `useEffect` alternative but executed after mounting of editor.\n */\nexport const useInstantEditorEffect = <R>(\n\tsemaphore: LifeCycleElementSemaphore<R> | null,\n\tfn: ( mountResult: R ) => void,\n\tdeps: DependencyList\n): void => {\n\tuseInstantEffect( () => {\n\t\tif ( semaphore ) {\n\t\t\tsemaphore.runAfterMount( fn );\n\t\t}\n\t}, [ semaphore, ...deps ] );\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { useRef, type DependencyList } from 'react';\nimport { shallowCompareArrays } from '../utils/shallowCompareArrays';\n\n/**\n * Triggers an effect immediately if the dependencies change (during rendering of component).\n *\n * @param fn The effect function to execute.\n * @param deps The dependency list.\n */\nexport const useInstantEffect = ( fn: VoidFunction, deps: DependencyList ): void => {\n\tconst prevDeps = useRef<any>( null );\n\n\tif ( !shallowCompareArrays( prevDeps.current, deps ) ) {\n\t\tprevDeps.current = [ ...deps ];\n\t\tfn();\n\t}\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport React, {\n\tforwardRef, useState, useEffect, useRef, useContext, useCallback, memo,\n\ttype Dispatch, type SetStateAction, type RefObject\n} from 'react';\n\nimport type { InlineEditableUIView } from '@ckeditor/ckeditor5-ui';\nimport type { EditorConfig } from '@ckeditor/ckeditor5-core';\nimport type { DocumentChangeEvent, Writer, RootElement } from '@ckeditor/ckeditor5-engine';\n\nimport { ContextWatchdog, EditorWatchdog } from '@ckeditor/ckeditor5-watchdog';\nimport type { WatchdogConfig } from '@ckeditor/ckeditor5-watchdog/src/watchdog';\n\nimport type { AddRootEvent, DetachRootEvent } from '@ckeditor/ckeditor5-editor-multi-root/src/multirooteditor';\nimport type MultiRootEditor from '@ckeditor/ckeditor5-build-multi-root';\nimport type EventInfo from '@ckeditor/ckeditor5-utils/src/eventinfo';\n\nimport { ContextWatchdogContext } from './ckeditorcontext';\nimport { EditorWatchdogAdapter } from './ckeditor';\n\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore';\n\nimport { useLifeCycleSemaphoreSyncRef, type LifeCycleSemaphoreSyncRefResult } from './lifecycle/useLifeCycleSemaphoreSyncRef';\nimport { mergeRefs } from './utils/mergeRefs';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore';\nimport { overwriteObject } from './utils/overwriteObject';\nimport { useRefSafeCallback } from './hooks/useRefSafeCallback';\nimport { uniq } from './utils/uniq';\nimport { overwriteArray } from './utils/overwriteArray';\nimport { useInstantEditorEffect } from './hooks/useInstantEditorEffect';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst useMultiRootEditor = ( props: MultiRootHookProps ): MultiRootHookReturns => {\n\tconst semaphoreElementRef = useRef<HTMLElement>( props.semaphoreElement || null );\n\tconst semaphore = useLifeCycleSemaphoreSyncRef<LifeCycleMountResult>();\n\n\tconst editorRefs: LifeCycleSemaphoreRefs<MultiRootEditor> = {\n\t\twatchdog: semaphore.createAttributeRef( 'watchdog' ),\n\t\tinstance: semaphore.createAttributeRef( 'instance' )\n\t};\n\n\tconst context = useContext( ContextWatchdogContext );\n\n\t// List of editor root elements.\n\tconst [ roots, setRoots ] = useState<Array<string>>( () => Object.keys( props.data ) );\n\n\t// Current editor data. An object where each key is a root name and the value is the root content.\n\tconst [ data, setData ] = useState<Record<string, string>>( { ...props.data } );\n\n\t// Current roots attributes. An object where each key is a root name and the value is an object with root attributes.\n\tconst [ attributes, setAttributes ] = useState<Record<string, Record<string, unknown>>>( { ...props.rootsAttributes } );\n\n\tconst shouldUpdateEditor = useRef<boolean>( true );\n\n\tuseEffect( () => {\n\t\tconst semaphoreElement = semaphoreElementRef.current;\n\n\t\tif ( !semaphoreElement || props.isLayoutReady === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\tsemaphore.replace( () => new LifeCycleElementSemaphore( semaphoreElement, {\n\t\t\tmount: _initializeEditor,\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = props;\n\n\t\t\t\tif ( onReady && semaphoreElementRef.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait _destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} ) );\n\n\t\treturn () => {\n\t\t\tsemaphore.release( false );\n\t\t};\n\t}, [ props.id, props.isLayoutReady ] );\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tconst _getConfig = (): EditorConfig => {\n\t\tconst config = props.config || {};\n\n\t\tif ( props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `data` property. ' +\n\t\t\t\t'The config value takes precedence over `data` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\t...config,\n\t\t\trootsAttributes: attributes\n\t\t};\n\t};\n\n\t/**\n\t * Callback function for handling changed data and attributes in the editor.\n\t */\n\tconst onChangeData = useRefSafeCallback( ( editor: MultiRootEditor, event: EventInfo ): void => {\n\t\tconst modelDocument = editor!.model.document;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tconst newData: Record<string, string> = {};\n\t\t\tconst newAttributes: Record<string, Record<string, unknown>> = {};\n\n\t\t\tmodelDocument.differ.getChanges()\n\t\t\t\t.forEach( change => {\n\t\t\t\t\tlet root: RootElement;\n\n\t\t\t\t\tif ( change.type == 'insert' || change.type == 'remove' ) {\n\t\t\t\t\t\troot = change.position.root as RootElement;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Must be `attribute` diff item.\n\t\t\t\t\t\troot = change.range.root as RootElement;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Getting data from a not attached root will trigger a warning.\n\t\t\t\t\t// There is another callback for handling detached roots.\n\t\t\t\t\tif ( !root.isAttached() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { rootName } = root;\n\n\t\t\t\t\tnewData[ rootName ] = editor!.getData( { rootName } );\n\t\t\t\t} );\n\n\t\t\tmodelDocument.differ.getChangedRoots()\n\t\t\t\t.forEach( changedRoot => {\n\t\t\t\t\t// Ignore added and removed roots. They are handled by a different function.\n\t\t\t\t\t// Only register if roots attributes changed.\n\t\t\t\t\tif ( changedRoot.state ) {\n\t\t\t\t\t\tif ( newData[ changedRoot.name ] !== undefined ) {\n\t\t\t\t\t\t\tdelete newData[ changedRoot.name ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rootName = changedRoot.name;\n\n\t\t\t\t\tnewAttributes[ rootName ] = editor!.getRootAttributes( rootName );\n\t\t\t\t} );\n\n\t\t\tif ( Object.keys( newData ).length ) {\n\t\t\t\tsetData( previousData => ( { ...previousData, ...newData } ) );\n\t\t\t}\n\n\t\t\tif ( Object.keys( newAttributes ).length ) {\n\t\t\t\tsetAttributes( previousAttributes => ( { ...previousAttributes, ...newAttributes } ) );\n\t\t\t}\n\t\t}\n\n\t\t/* istanbul ignore else */\n\t\tif ( props.onChange ) {\n\t\t\tprops.onChange( event, editor! );\n\t\t}\n\t} );\n\n\t/**\n\t * Callback function for handling an added root.\n\t */\n\tconst onAddRoot = useRefSafeCallback( ( editor: MultiRootEditor, evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData =>\n\t\t\t\t( { ...previousData, [ rootName ]: editor!.getData( { rootName } ) } )\n\t\t\t);\n\n\t\t\tsetAttributes( previousAttributes =>\n\t\t\t\t( { ...previousAttributes, [ rootName ]: editor!.getRootAttributes( rootName ) } )\n\t\t\t);\n\t\t}\n\n\t\tsetRoots( prevRoots => uniq( [ ...prevRoots, root.rootName ] ) );\n\t} );\n\n\t/**\n\t * Callback function for handling a detached root.\n\t */\n\tconst onDetachRoot = useRefSafeCallback( ( editor: MultiRootEditor, evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData => {\n\t\t\t\tconst { [ rootName! ]: _, ...newData } = previousData;\n\n\t\t\t\treturn { ...newData };\n\t\t\t} );\n\n\t\t\tsetAttributes( previousAttributes => {\n\t\t\t\tconst { [ rootName! ]: _, ...newAttributes } = previousAttributes;\n\n\t\t\t\treturn { ...newAttributes };\n\t\t\t} );\n\t\t}\n\n\t\tsetRoots( prevRoots => prevRoots.filter( root => root !== rootName ) );\n\t} );\n\n\t/**\n\t * Creates an editor using initial elements or data, and configuration.\n\t *\n\t * @param initialData The initial data.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tconst _createEditor = useRefSafeCallback( (\n\t\tinitialData: Record<string, string> | Record<string, HTMLElement>,\n\t\tconfig: EditorConfig\n\t): Promise<MultiRootEditor> => {\n\t\toverwriteObject( { ...props.rootsAttributes }, attributes );\n\t\toverwriteObject( { ...props.data }, data );\n\t\toverwriteArray( Object.keys( props.data ), roots );\n\n\t\treturn props.editor.create( initialData, config )\n\t\t\t.then( ( editor: MultiRootEditor ) => {\n\t\t\t\tconst editorData = editor.getFullData();\n\n\t\t\t\t// Rerender will be called anyway.\n\t\t\t\toverwriteObject( { ...editorData }, data );\n\t\t\t\toverwriteObject( { ...editor.getRootsAttributes() }, attributes );\n\t\t\t\toverwriteArray( Object.keys( editorData ), roots );\n\n\t\t\t\tif ( props.disabled ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', evt => onChangeData( editor, evt ) );\n\n\t\t\t\teditor.on<AddRootEvent>( 'addRoot', ( evt, root ) => onAddRoot( editor, evt, root ) );\n\t\t\t\teditor.on<DetachRootEvent>( 'detachRoot', ( evt, root ) => onDetachRoot( editor, evt, root ) );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( props.onFocus ) {\n\t\t\t\t\t\tprops.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( props.onBlur ) {\n\t\t\t\t\t\tprops.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t} );\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tconst _destroyEditor = ( initializeResult: EditorSemaphoreMountResult<MultiRootEditor> ): Promise<void> => {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tconst _initializeEditor = async (): Promise<LifeCycleMountResult> => {\n\t\tif ( props.disableWatchdog ) {\n\t\t\tconst instance = await _createEditor( props.data as any, _getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as MultiRootEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\tif ( context instanceof ContextWatchdog ) {\n\t\t\t\treturn new EditorWatchdogAdapter( context );\n\t\t\t}\n\n\t\t\treturn new EditorWatchdog( props.editor, props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<MultiRootEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\twatchdog.setCreator( async ( data, config ) => {\n\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\tif ( totalRestartsRef.current > 0 && onAfterDestroy && editorRefs.instance.current ) {\n\t\t\t\tonAfterDestroy( editorRefs.instance.current );\n\t\t\t}\n\n\t\t\tconst instance = await _createEditor( data as any, config );\n\n\t\t\tif ( totalRestartsRef.current > 0 ) {\n\t\t\t\tsemaphore.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\tif ( props.onReady ) {\n\t\t\t\t\t\tprops.onReady( watchdog!.editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog\n\t\t\t.create( data as any, _getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t\tthrow error;\n\t\t\t} );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t};\n\n\tconst _getStateDiff = (\n\t\tpreviousState: Record<string, unknown>,\n\t\tnewState: Record<string, unknown>\n\t): {\n\t\taddedKeys: Array<string>;\n\t\tremovedKeys: Array<string>;\n\t} => {\n\t\tconst previousStateKeys = Object.keys( previousState );\n\t\tconst newStateKeys = Object.keys( newState );\n\n\t\treturn {\n\t\t\taddedKeys: newStateKeys.filter( key => !previousStateKeys.includes( key ) ),\n\t\t\tremovedKeys: previousStateKeys.filter( key => !newStateKeys.includes( key ) )\n\t\t};\n\t};\n\n\tconst _externalSetData: Dispatch<SetStateAction<Record<string, string>>> = useCallback(\n\t\tnewData => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetData( newData );\n\t\t\t} );\n\t\t},\n\t\t[ setData ]\n\t);\n\n\tconst _externalSetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>> = useCallback(\n\t\tnewAttributes => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetAttributes( newAttributes );\n\t\t\t} );\n\t\t},\n\t\t[ setAttributes ]\n\t);\n\n\tconst toolbarElement = (\n\t\t<EditorToolbarWrapper\n\t\t\tref={ semaphoreElementRef }\n\t\t\teditor={editorRefs.instance.current}\n\t\t/>\n\t);\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\tif ( props.disabled ) {\n\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t} else {\n\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t}\n\t}, [ props.disabled ] );\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\t// Editor should be only updated when the changes come from the integrator React application.\n\t\tif ( shouldUpdateEditor.current ) {\n\t\t\tshouldUpdateEditor.current = false;\n\n\t\t\tconst dataKeys = Object.keys( data );\n\t\t\tconst attributesKeys = Object.keys( attributes );\n\n\t\t\t// Check if `data` and `attributes` have the same keys.\n\t\t\t//\n\t\t\t// It prevents the addition of attributes for non-existing roots.\n\t\t\t// If the `data` object has a different set of keys, an error will not be thrown\n\t\t\t// since the attributes will be removed/added during root initialization/destruction.\n\t\t\tif ( !dataKeys.every( key => attributesKeys.includes( key ) ) ) {\n\t\t\t\tconsole.error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t\tthrow new Error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t}\n\n\t\t\tconst editorData = instance.getFullData();\n\t\t\tconst editorAttributes = instance.getRootsAttributes();\n\n\t\t\tconst {\n\t\t\t\taddedKeys: newRoots,\n\t\t\t\tremovedKeys: removedRoots\n\t\t\t} = _getStateDiff( editorData, data || {} );\n\n\t\t\tconst hasModifiedData = dataKeys.some( rootName =>\n\t\t\t\teditorData[ rootName ] !== undefined &&\n\t\t\t\tJSON.stringify( editorData[ rootName ] ) !== JSON.stringify( data[ rootName ] )\n\t\t\t);\n\n\t\t\tconst rootsWithChangedAttributes = attributesKeys.filter( rootName =>\n\t\t\t\tJSON.stringify( editorAttributes[ rootName ] ) !== JSON.stringify( attributes[ rootName ] ) );\n\n\t\t\tconst _handleNewRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.addRoot( rootName, {\n\t\t\t\t\t\tdata: data[ rootName ] || '',\n\t\t\t\t\t\tattributes: attributes?.[ rootName ] || {},\n\t\t\t\t\t\tisUndoable: true\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _handleRemovedRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.detachRoot( rootName, true );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _updateEditorData = () => {\n\t\t\t\t// If any of the roots content has changed, set the editor data.\n\t\t\t\t// Unfortunately, we cannot set the editor data just for one root,\n\t\t\t\t// so we need to overwrite all roots (`nextProps.data` is an\n\t\t\t\t// object with data for each root).\n\t\t\t\tinstance.data.set( data, { suppressErrorInCollaboration: true } as any );\n\t\t\t};\n\n\t\t\tconst _updateEditorAttributes = ( writer: Writer, roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tObject.keys( attributes![ rootName ] ).forEach( attr => {\n\t\t\t\t\t\tinstance.registerRootAttribute( attr );\n\t\t\t\t\t} );\n\n\t\t\t\t\twriter.clearAttributes( instance.model.document.getRoot( rootName )! );\n\t\t\t\t\twriter.setAttributes( attributes![ rootName ], instance.model.document.getRoot( rootName )! );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\t// React struggles with rerendering during `instance.model.change` callbacks.\n\t\t\tsetTimeout( () => {\n\t\t\t\tinstance.model.change( writer => {\n\t\t\t\t\t_handleNewRoots( newRoots );\n\t\t\t\t\t_handleRemovedRoots( removedRoots );\n\n\t\t\t\t\tif ( hasModifiedData ) {\n\t\t\t\t\t\t_updateEditorData();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( rootsWithChangedAttributes.length ) {\n\t\t\t\t\t\t_updateEditorAttributes( writer, rootsWithChangedAttributes );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t}, [ data, attributes ] );\n\n\tconst editableElements = roots.map(\n\t\trootName => (\n\t\t\t<EditorEditable\n\t\t\t\tkey={rootName}\n\t\t\t\tid={rootName}\n\t\t\t\trootName={rootName}\n\t\t\t\tsemaphore={semaphore}\n\t\t\t/>\n\t\t)\n\t);\n\n\treturn {\n\t\teditor: editorRefs.instance.current,\n\t\teditableElements,\n\t\ttoolbarElement,\n\t\tdata, setData: _externalSetData,\n\t\tattributes, setAttributes: _externalSetAttributes\n\t};\n};\n\nconst EditorEditable = memo( forwardRef( ( { id, semaphore, rootName }: {\n\tid: string;\n\trootName: string;\n\tsemaphore: LifeCycleSemaphoreSyncRefResult<LifeCycleMountResult>;\n}, ref ) => {\n\tconst innerRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tlet editable: InlineEditableUIView | null;\n\t\tlet editor: MultiRootEditor | null;\n\n\t\tsemaphore.runAfterMount( ( { instance } ) => {\n\t\t\tif ( innerRef.current ) {\n\t\t\t\teditor = instance;\n\t\t\t\teditable = instance.ui.view.createEditable( rootName, innerRef.current );\n\n\t\t\t\tinstance.ui.addEditable( editable );\n\t\t\t\tinstance.editing.view.forceRender();\n\t\t\t}\n\t\t} );\n\n\t\treturn () => {\n\t\t\tif ( editable && innerRef.current && editor && editor.state !== 'destroyed' ) {\n\t\t\t\teditor.ui.removeEditable( editable );\n\t\t\t}\n\t\t};\n\t}, [ semaphore.revision ] );\n\n\treturn (\n\t\t<div\n\t\t\tkey={semaphore.revision}\n\t\t\tid={id}\n\t\t\tref={ mergeRefs( ref, innerRef ) }\n\t\t/>\n\t);\n} ) );\n\nEditorEditable.displayName = 'EditorEditable';\n\nconst EditorToolbarWrapper = forwardRef( ( { editor }: any, ref ) => {\n\tconst toolbarRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tconst toolbarContainer = toolbarRef.current;\n\n\t\tif ( !editor || !toolbarContainer ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst element = editor.ui.view.toolbar.element!;\n\n\t\tif ( toolbarContainer ) {\n\t\t\ttoolbarContainer.appendChild( element! );\n\t\t}\n\n\t\treturn () => {\n\t\t\tif ( toolbarContainer ) {\n\t\t\t\ttoolbarContainer.removeChild( element! );\n\t\t\t}\n\t\t};\n\t}, [ editor && editor.id ] );\n\n\treturn <div ref={mergeRefs( toolbarRef, ref )}></div>;\n} );\n\nEditorToolbarWrapper.displayName = 'EditorToolbarWrapper';\n\nexport default useMultiRootEditor;\n\ntype LifeCycleMountResult = EditorSemaphoreMountResult<MultiRootEditor>;\n\ntype LifeCycleSemaphoreRefs<TEditor extends MultiRootEditor> = {\n\t[ K in keyof EditorSemaphoreMountResult<TEditor> ]: RefObject<EditorSemaphoreMountResult<TEditor>[ K ]>\n};\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\nexport type MultiRootHookProps = {\n\tid?: any;\n\tsemaphoreElement?: HTMLElement;\n\n\tisLayoutReady?: boolean;\n\tdisabled?: boolean;\n\tdata: Record<string, string>;\n\trootsAttributes?: Record<string, Record<string, unknown>>;\n\teditor: typeof MultiRootEditor;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tdisableTwoWayDataBinding?: boolean;\n\n\tonReady?: ( editor: MultiRootEditor ) => void;\n\tonAfterDestroy?: ( editor: MultiRootEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\n\tconfig?: Record<string, unknown>;\n};\n\nexport type MultiRootHookReturns = {\n\teditor: MultiRootEditor | null;\n\teditableElements: Array<JSX.Element>;\n\ttoolbarElement: JSX.Element;\n\tdata: Record<string, string>;\n\tsetData: Dispatch<SetStateAction<Record<string, string>>>;\n\tattributes: Record<string, Record<string, unknown>>;\n\tsetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>>;\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { useRef, useState, type RefObject } from 'react';\nimport type { LifeCycleElementSemaphore, LifeCycleAfterMountCallback } from './LifeCycleElementSemaphore';\n\n/**\n * When using the `useState` approach, a new instance of the semaphore must be set based on the previous\n * one within the `setState` callback, as shown in this example:\n *\n * \t\tsetState( prevSemaphore => ... )\n *\n * The issue arises from the uncertainty of whether React has batched and cancelled some `setState` calls.\n * This means that setting the state with a semaphore three times might result in the collapsing of these three calls into a single one.\n *\n * Although this may not seem like a significant issue in theory, it can lead to a multitude of minor issues in practice that may\n * generate race conditions. This is because semaphores handle batching independently.\n *\n * A solution involving refs is safer in terms of preserving object references. In other words, `semaphoreRef.current` is guaranteed to\n * always point to the most recent instance of the semaphore.\n */\nexport const useLifeCycleSemaphoreSyncRef = <R extends object>(): LifeCycleSemaphoreSyncRefResult<R> => {\n\tconst semaphoreRef = useRef<LifeCycleElementSemaphore<R> | null>( null );\n\tconst [ revision, setRevision ] = useState( () => Date.now() );\n\n\tconst refresh = () => {\n\t\tsetRevision( Date.now() );\n\t};\n\n\tconst release = ( rerender: boolean = true ) => {\n\t\tif ( semaphoreRef.current ) {\n\t\t\tsemaphoreRef.current.release();\n\t\t\tsemaphoreRef.current = null;\n\t\t}\n\n\t\tif ( rerender ) {\n\t\t\tsetRevision( Date.now() );\n\t\t}\n\t};\n\n\tconst unsafeSetValue = ( value: R ) => {\n\t\tsemaphoreRef.current?.unsafeSetValue( value );\n\t\trefresh();\n\t};\n\n\tconst runAfterMount = ( callback: LifeCycleAfterMountCallback<R> ) => {\n\t\tif ( semaphoreRef.current ) {\n\t\t\tsemaphoreRef.current.runAfterMount( callback );\n\t\t}\n\t};\n\n\tconst replace = ( newSemaphore: () => LifeCycleElementSemaphore<R> ) => {\n\t\trelease( false );\n\t\tsemaphoreRef.current = newSemaphore();\n\n\t\trefresh();\n\t\trunAfterMount( refresh );\n\t};\n\n\tconst createAttributeRef = <K extends keyof R>( key: K ): RefObject<R[ K ]> => ( {\n\t\tget current() {\n\t\t\tif ( !semaphoreRef.current || !semaphoreRef.current.value ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn semaphoreRef.current.value[ key ];\n\t\t}\n\t} );\n\n\treturn {\n\t\tget current() {\n\t\t\treturn semaphoreRef.current;\n\t\t},\n\t\trevision,\n\t\tcreateAttributeRef,\n\t\tunsafeSetValue,\n\t\trelease,\n\t\treplace,\n\t\trunAfterMount\n\t};\n};\n\nexport type LifeCycleSemaphoreSyncRefResult<R> = RefObject<LifeCycleElementSemaphore<R>> & {\n\trevision: number;\n\tunsafeSetValue: ( value: R ) => void;\n\trunAfterMount: ( callback: LifeCycleAfterMountCallback<R> ) => void;\n\trelease: ( rerender?: boolean ) => void;\n\treplace: ( newSemaphore: () => LifeCycleElementSemaphore<R> ) => void;\n\tcreateAttributeRef: <K extends keyof R>( key: K ) => RefObject<R[ K ]>;\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * A utility function that removes duplicate elements from an array.\n */\nexport function uniq<A>( source: Array<A> ): Array<A> {\n\treturn Array.from( new Set( source ) );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}