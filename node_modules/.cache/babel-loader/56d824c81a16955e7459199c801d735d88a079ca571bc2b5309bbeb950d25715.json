{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * An abstract watchdog class that handles most of the error handling process and the state of the underlying component.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and how to use it.\n *\n * @internal\n */\nexport default class Watchdog {\n  /**\n   * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.\n   */\n  constructor(config) {\n    /**\n     * An array of crashes saved as an object with the following properties:\n     *\n     * * `message`: `String`,\n     * * `stack`: `String`,\n     * * `date`: `Number`,\n     * * `filename`: `String | undefined`,\n     * * `lineno`: `Number | undefined`,\n     * * `colno`: `Number | undefined`,\n     */\n    this.crashes = [];\n    /**\n     * Specifies the state of the item watched by the watchdog. The state can be one of the following values:\n     *\n     * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.\n     * * `ready` &ndash; A state when the user can interact with the item.\n     * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`\n     * depending on how many and how frequent errors have been caught recently.\n     * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,\n     * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.\n     */\n    this.state = 'initializing';\n    /**\n     * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular\n     * approaches like `sinon.useFakeTimers()` do not work well with error handling.\n     */\n    this._now = Date.now;\n    this.crashes = [];\n    this._crashNumberLimit = typeof config.crashNumberLimit === 'number' ? config.crashNumberLimit : 3;\n    this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === 'number' ? config.minimumNonErrorTimePeriod : 5000;\n    this._boundErrorHandler = evt => {\n      // `evt.error` is exposed by EventError while `evt.reason` is available in PromiseRejectionEvent.\n      const error = 'error' in evt ? evt.error : evt.reason;\n      // Note that `evt.reason` might be everything that is in the promise rejection.\n      // Similarly everything that is thrown lands in `evt.error`.\n      if (error instanceof Error) {\n        this._handleError(error, evt);\n      }\n    };\n    this._listeners = {};\n    if (!this._restart) {\n      throw new Error('The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' + 'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.');\n    }\n  }\n  /**\n   * Destroys the watchdog and releases the resources.\n   */\n  destroy() {\n    this._stopErrorHandling();\n    this._listeners = {};\n  }\n  /**\n   * Starts listening to a specific event name by registering a callback that will be executed\n   * whenever an event with a given name fires.\n   *\n   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n   *\n   * @param eventName The event name.\n   * @param callback A callback which will be added to event listeners.\n   */\n  on(eventName, callback) {\n    if (!this._listeners[eventName]) {\n      this._listeners[eventName] = [];\n    }\n    this._listeners[eventName].push(callback);\n  }\n  /**\n   * Stops listening to the specified event name by removing the callback from event listeners.\n   *\n   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n   *\n   * @param eventName The event name.\n   * @param callback A callback which will be removed from event listeners.\n   */\n  off(eventName, callback) {\n    this._listeners[eventName] = this._listeners[eventName].filter(cb => cb !== callback);\n  }\n  /**\n   * Fires an event with a given event name and arguments.\n   *\n   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n   */\n  _fire(eventName, ...args) {\n    const callbacks = this._listeners[eventName] || [];\n    for (const callback of callbacks) {\n      callback.apply(this, [null, ...args]);\n    }\n  }\n  /**\n   * Starts error handling by attaching global error handlers.\n   */\n  _startErrorHandling() {\n    window.addEventListener('error', this._boundErrorHandler);\n    window.addEventListener('unhandledrejection', this._boundErrorHandler);\n  }\n  /**\n   * Stops error handling by detaching global error handlers.\n   */\n  _stopErrorHandling() {\n    window.removeEventListener('error', this._boundErrorHandler);\n    window.removeEventListener('unhandledrejection', this._boundErrorHandler);\n  }\n  /**\n   * Checks if an error comes from the watched item and restarts it.\n   * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.\n   *\n   * @fires error\n   * @param error Error.\n   * @param evt An error event.\n   */\n  _handleError(error, evt) {\n    // @if CK_DEBUG // const err = error as CKEditorError;\n    // @if CK_DEBUG // if ( err.is && err.is( 'CKEditorError' ) && err.context === undefined ) {\n    // @if CK_DEBUG // console.warn( 'The error is missing its context and Watchdog cannot restart the proper item.' );\n    // @if CK_DEBUG // }\n    if (this._shouldReactToError(error)) {\n      this.crashes.push({\n        message: error.message,\n        stack: error.stack,\n        // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events\n        filename: evt instanceof ErrorEvent ? evt.filename : undefined,\n        lineno: evt instanceof ErrorEvent ? evt.lineno : undefined,\n        colno: evt instanceof ErrorEvent ? evt.colno : undefined,\n        date: this._now()\n      });\n      const causesRestart = this._shouldRestart();\n      this.state = 'crashed';\n      this._fire('stateChange');\n      this._fire('error', {\n        error,\n        causesRestart\n      });\n      if (causesRestart) {\n        this._restart();\n      } else {\n        this.state = 'crashedPermanently';\n        this._fire('stateChange');\n      }\n    }\n  }\n  /**\n   * Checks whether an error should be handled by the watchdog.\n   *\n   * @param error An error that was caught by the error handling process.\n   */\n  _shouldReactToError(error) {\n    return error.is && error.is('CKEditorError') && error.context !== undefined &&\n    // In some cases the watched item should not be restarted - e.g. during the item initialization.\n    // That's why the `null` was introduced as a correct error context which does cause restarting.\n    error.context !== null &&\n    // Do not react to errors if the watchdog is in states other than `ready`.\n    this.state === 'ready' && this._isErrorComingFromThisItem(error);\n  }\n  /**\n   * Checks if the watchdog should restart the underlying item.\n   */\n  _shouldRestart() {\n    if (this.crashes.length <= this._crashNumberLimit) {\n      return true;\n    }\n    const lastErrorTime = this.crashes[this.crashes.length - 1].date;\n    const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;\n    const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;\n    return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;\n  }\n}","map":{"version":3,"names":["Watchdog","constructor","config","crashes","state","_now","Date","now","_crashNumberLimit","crashNumberLimit","_minimumNonErrorTimePeriod","minimumNonErrorTimePeriod","_boundErrorHandler","evt","error","reason","Error","_handleError","_listeners","_restart","destroy","_stopErrorHandling","on","eventName","callback","push","off","filter","cb","_fire","args","callbacks","apply","_startErrorHandling","window","addEventListener","removeEventListener","_shouldReactToError","message","stack","filename","ErrorEvent","undefined","lineno","colno","date","causesRestart","_shouldRestart","is","context","_isErrorComingFromThisItem","length","lastErrorTime","firstMeaningfulErrorTime","averageNonErrorTimePeriod"],"sources":["D:/DubaiMusic/dubai-music/node_modules/@ckeditor/ckeditor5-watchdog/src/watchdog.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * An abstract watchdog class that handles most of the error handling process and the state of the underlying component.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and how to use it.\n *\n * @internal\n */\nexport default class Watchdog {\n    /**\n     * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.\n     */\n    constructor(config) {\n        /**\n         * An array of crashes saved as an object with the following properties:\n         *\n         * * `message`: `String`,\n         * * `stack`: `String`,\n         * * `date`: `Number`,\n         * * `filename`: `String | undefined`,\n         * * `lineno`: `Number | undefined`,\n         * * `colno`: `Number | undefined`,\n         */\n        this.crashes = [];\n        /**\n         * Specifies the state of the item watched by the watchdog. The state can be one of the following values:\n         *\n         * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.\n         * * `ready` &ndash; A state when the user can interact with the item.\n         * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`\n         * depending on how many and how frequent errors have been caught recently.\n         * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,\n         * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.\n         */\n        this.state = 'initializing';\n        /**\n         * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular\n         * approaches like `sinon.useFakeTimers()` do not work well with error handling.\n         */\n        this._now = Date.now;\n        this.crashes = [];\n        this._crashNumberLimit = typeof config.crashNumberLimit === 'number' ? config.crashNumberLimit : 3;\n        this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === 'number' ? config.minimumNonErrorTimePeriod : 5000;\n        this._boundErrorHandler = evt => {\n            // `evt.error` is exposed by EventError while `evt.reason` is available in PromiseRejectionEvent.\n            const error = 'error' in evt ? evt.error : evt.reason;\n            // Note that `evt.reason` might be everything that is in the promise rejection.\n            // Similarly everything that is thrown lands in `evt.error`.\n            if (error instanceof Error) {\n                this._handleError(error, evt);\n            }\n        };\n        this._listeners = {};\n        if (!this._restart) {\n            throw new Error('The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' +\n                'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.');\n        }\n    }\n    /**\n     * Destroys the watchdog and releases the resources.\n     */\n    destroy() {\n        this._stopErrorHandling();\n        this._listeners = {};\n    }\n    /**\n     * Starts listening to a specific event name by registering a callback that will be executed\n     * whenever an event with a given name fires.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     *\n     * @param eventName The event name.\n     * @param callback A callback which will be added to event listeners.\n     */\n    on(eventName, callback) {\n        if (!this._listeners[eventName]) {\n            this._listeners[eventName] = [];\n        }\n        this._listeners[eventName].push(callback);\n    }\n    /**\n     * Stops listening to the specified event name by removing the callback from event listeners.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     *\n     * @param eventName The event name.\n     * @param callback A callback which will be removed from event listeners.\n     */\n    off(eventName, callback) {\n        this._listeners[eventName] = this._listeners[eventName]\n            .filter(cb => cb !== callback);\n    }\n    /**\n     * Fires an event with a given event name and arguments.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     */\n    _fire(eventName, ...args) {\n        const callbacks = this._listeners[eventName] || [];\n        for (const callback of callbacks) {\n            callback.apply(this, [null, ...args]);\n        }\n    }\n    /**\n     * Starts error handling by attaching global error handlers.\n     */\n    _startErrorHandling() {\n        window.addEventListener('error', this._boundErrorHandler);\n        window.addEventListener('unhandledrejection', this._boundErrorHandler);\n    }\n    /**\n     * Stops error handling by detaching global error handlers.\n     */\n    _stopErrorHandling() {\n        window.removeEventListener('error', this._boundErrorHandler);\n        window.removeEventListener('unhandledrejection', this._boundErrorHandler);\n    }\n    /**\n     * Checks if an error comes from the watched item and restarts it.\n     * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.\n     *\n     * @fires error\n     * @param error Error.\n     * @param evt An error event.\n     */\n    _handleError(error, evt) {\n        // @if CK_DEBUG // const err = error as CKEditorError;\n        // @if CK_DEBUG // if ( err.is && err.is( 'CKEditorError' ) && err.context === undefined ) {\n        // @if CK_DEBUG // console.warn( 'The error is missing its context and Watchdog cannot restart the proper item.' );\n        // @if CK_DEBUG // }\n        if (this._shouldReactToError(error)) {\n            this.crashes.push({\n                message: error.message,\n                stack: error.stack,\n                // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events\n                filename: evt instanceof ErrorEvent ? evt.filename : undefined,\n                lineno: evt instanceof ErrorEvent ? evt.lineno : undefined,\n                colno: evt instanceof ErrorEvent ? evt.colno : undefined,\n                date: this._now()\n            });\n            const causesRestart = this._shouldRestart();\n            this.state = 'crashed';\n            this._fire('stateChange');\n            this._fire('error', { error, causesRestart });\n            if (causesRestart) {\n                this._restart();\n            }\n            else {\n                this.state = 'crashedPermanently';\n                this._fire('stateChange');\n            }\n        }\n    }\n    /**\n     * Checks whether an error should be handled by the watchdog.\n     *\n     * @param error An error that was caught by the error handling process.\n     */\n    _shouldReactToError(error) {\n        return (error.is &&\n            error.is('CKEditorError') &&\n            error.context !== undefined &&\n            // In some cases the watched item should not be restarted - e.g. during the item initialization.\n            // That's why the `null` was introduced as a correct error context which does cause restarting.\n            error.context !== null &&\n            // Do not react to errors if the watchdog is in states other than `ready`.\n            this.state === 'ready' &&\n            this._isErrorComingFromThisItem(error));\n    }\n    /**\n     * Checks if the watchdog should restart the underlying item.\n     */\n    _shouldRestart() {\n        if (this.crashes.length <= this._crashNumberLimit) {\n            return true;\n        }\n        const lastErrorTime = this.crashes[this.crashes.length - 1].date;\n        const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;\n        const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;\n        return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}