{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Watchdog from './watchdog.js';\nimport EditorWatchdog from './editorwatchdog.js';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties.js';\nimport getSubNodes from './utils/getsubnodes.js';\nconst mainQueueId = Symbol('MainQueueId');\n/**\n * A watchdog for the {@link module:core/context~Context} class.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class ContextWatchdog extends Watchdog {\n  /**\n   * The context watchdog class constructor.\n   *\n   * ```ts\n   * const watchdog = new ContextWatchdog( Context );\n   *\n   * await watchdog.create( contextConfiguration );\n   *\n   * await watchdog.add( item );\n   * ```\n   *\n   * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\n   *\n   * @param Context The {@link module:core/context~Context} class.\n   * @param watchdogConfig The watchdog configuration.\n   */\n  constructor(Context) {\n    let watchdogConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(watchdogConfig);\n    /**\n     * A map of internal watchdogs for added items.\n     */\n    this._watchdogs = new Map();\n    /**\n     * The current context instance.\n     */\n    this._context = null;\n    /**\n     * Context properties (nodes/references) that are gathered during the initial context creation\n     * and are used to distinguish the origin of an error.\n     */\n    this._contextProps = new Set();\n    /**\n     * An action queue, which is used to handle async functions queuing.\n     */\n    this._actionQueues = new ActionQueues();\n    this._watchdogConfig = watchdogConfig;\n    // Default creator and destructor.\n    this._creator = contextConfig => Context.create(contextConfig);\n    this._destructor = context => context.destroy();\n    this._actionQueues.onEmpty(() => {\n      if (this.state === 'initializing') {\n        this.state = 'ready';\n        this._fire('stateChange');\n      }\n    });\n  }\n  /**\n   * Sets the function that is responsible for the context creation.\n   * It expects a function that should return a promise (or `undefined`).\n   *\n   * ```ts\n   * watchdog.setCreator( config => Context.create( config ) );\n   * ```\n   */\n  setCreator(creator) {\n    this._creator = creator;\n  }\n  /**\n   * Sets the function that is responsible for the context destruction.\n   * Overrides the default destruction function, which destroys only the context instance.\n   * It expects a function that should return a promise (or `undefined`).\n   *\n   * ```ts\n   * watchdog.setDestructor( context => {\n   * \t// Do something before the context is destroyed.\n   *\n   * \treturn context\n   * \t\t.destroy()\n   * \t\t.then( () => {\n   * \t\t\t// Do something after the context is destroyed.\n   * \t\t} );\n   * } );\n   * ```\n   */\n  setDestructor(destructor) {\n    this._destructor = destructor;\n  }\n  /**\n   * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\n   * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\n   */\n  get context() {\n    return this._context;\n  }\n  /**\n   * Initializes the context watchdog. Once it is created, the watchdog takes care about\n   * recreating the context and the provided items, and starts the error handling mechanism.\n   *\n   * ```ts\n   * await watchdog.create( {\n   * \tplugins: []\n   * } );\n   * ```\n   *\n   * @param contextConfig The context configuration. See {@link module:core/context~Context}.\n   */\n  create() {\n    let contextConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this._contextConfig = contextConfig;\n      return this._create();\n    });\n  }\n  /**\n   * Returns an item instance with the given `itemId`.\n   *\n   * ```ts\n   * const editor1 = watchdog.getItem( 'editor1' );\n   * ```\n   *\n   * @param itemId The item ID.\n   * @returns The item instance or `undefined` if an item with a given ID has not been found.\n   */\n  getItem(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n    return watchdog._item;\n  }\n  /**\n   * Gets the state of the given item. See {@link #state} for a list of available states.\n   *\n   * ```ts\n   * const editor1State = watchdog.getItemState( 'editor1' );\n   * ```\n   *\n   * @param itemId Item ID.\n   * @returns The state of the item.\n   */\n  getItemState(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n    return watchdog.state;\n  }\n  /**\n   * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\n   *\n   * Items can be passed together as an array of objects:\n   *\n   * ```ts\n   * await watchdog.add( [ {\n   * \tid: 'editor1',\n   * \ttype: 'editor',\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\n   * \tconfig: {\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n   * \t},\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n   * } ] );\n   * ```\n   *\n   * Or one by one as objects:\n   *\n   * ```ts\n   * await watchdog.add( {\n   * \tid: 'editor1',\n   * \ttype: 'editor',\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\n   * \tconfig: {\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n   * \t},\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n   * ] );\n   * ```\n   *\n   * Then an instance can be retrieved using the {@link #getItem} method:\n   *\n   * ```ts\n   * const editor1 = watchdog.getItem( 'editor1' );\n   * ```\n   *\n   * Note that this method can be called multiple times, but for performance reasons it is better\n   * to pass all items together.\n   *\n   * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\n   */\n  add(itemConfigurationOrItemConfigurations) {\n    const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n    return Promise.all(itemConfigurations.map(item => {\n      return this._actionQueues.enqueue(item.id, () => {\n        if (this.state === 'destroyed') {\n          throw new Error('Cannot add items to destroyed watchdog.');\n        }\n        if (!this._context) {\n          throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n        }\n        let watchdog;\n        if (this._watchdogs.has(item.id)) {\n          throw new Error(\"Item with the given id is already added: '\".concat(item.id, \"'.\"));\n        }\n        if (item.type === 'editor') {\n          watchdog = new EditorWatchdog(null, this._watchdogConfig);\n          watchdog.setCreator(item.creator);\n          watchdog._setExcludedProperties(this._contextProps);\n          if (item.destructor) {\n            watchdog.setDestructor(item.destructor);\n          }\n          this._watchdogs.set(item.id, watchdog);\n          // Enqueue the internal watchdog errors within the main queue.\n          // And propagate the internal `error` events as `itemError` event.\n          watchdog.on('error', (evt, _ref) => {\n            let {\n              error,\n              causesRestart\n            } = _ref;\n            this._fire('itemError', {\n              itemId: item.id,\n              error\n            });\n            // Do not enqueue the item restart action if the item will not restart.\n            if (!causesRestart) {\n              return;\n            }\n            this._actionQueues.enqueue(item.id, () => new Promise(res => {\n              const rethrowRestartEventOnce = () => {\n                watchdog.off('restart', rethrowRestartEventOnce);\n                this._fire('itemRestart', {\n                  itemId: item.id\n                });\n                res();\n              };\n              watchdog.on('restart', rethrowRestartEventOnce);\n            }));\n          });\n          return watchdog.create(item.sourceElementOrData, item.config, this._context);\n        } else {\n          throw new Error(\"Not supported item type: '\".concat(item.type, \"'.\"));\n        }\n      });\n    }));\n  }\n  /**\n   * Removes and destroys item(s) with given ID(s).\n   *\n   * ```ts\n   * await watchdog.remove( 'editor1' );\n   * ```\n   *\n   * Or\n   *\n   * ```ts\n   * await watchdog.remove( [ 'editor1', 'editor2' ] );\n   * ```\n   *\n   * @param itemIdOrItemIds Item ID or an array of item IDs.\n   */\n  remove(itemIdOrItemIds) {\n    const itemIds = toArray(itemIdOrItemIds);\n    return Promise.all(itemIds.map(itemId => {\n      return this._actionQueues.enqueue(itemId, () => {\n        const watchdog = this._getWatchdog(itemId);\n        this._watchdogs.delete(itemId);\n        return watchdog.destroy();\n      });\n    }));\n  }\n  /**\n   * Destroys the context watchdog and all added items.\n   * Once the context watchdog is destroyed, new items cannot be added.\n   *\n   * ```ts\n   * await watchdog.destroy();\n   * ```\n   */\n  destroy() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'destroyed';\n      this._fire('stateChange');\n      super.destroy();\n      return this._destroy();\n    });\n  }\n  /**\n   * Restarts the context watchdog.\n   */\n  _restart() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'initializing';\n      this._fire('stateChange');\n      return this._destroy().catch(err => {\n        console.error('An error happened during destroying the context or items.', err);\n      }).then(() => this._create()).then(() => this._fire('restart'));\n    });\n  }\n  /**\n   * Initializes the context watchdog.\n   */\n  _create() {\n    return Promise.resolve().then(() => {\n      this._startErrorHandling();\n      return this._creator(this._contextConfig);\n    }).then(context => {\n      this._context = context;\n      this._contextProps = getSubNodes(this._context);\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => {\n        watchdog._setExcludedProperties(this._contextProps);\n        return watchdog.create(undefined, undefined, this._context);\n      }));\n    });\n  }\n  /**\n   * Destroys the context instance and all added items.\n   */\n  _destroy() {\n    return Promise.resolve().then(() => {\n      this._stopErrorHandling();\n      const context = this._context;\n      this._context = null;\n      this._contextProps = new Set();\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => watchdog.destroy()))\n      // Context destructor destroys each editor.\n      .then(() => this._destructor(context));\n    });\n  }\n  /**\n   * Returns the watchdog for a given item ID.\n   *\n   * @param itemId Item ID.\n   */\n  _getWatchdog(itemId) {\n    const watchdog = this._watchdogs.get(itemId);\n    if (!watchdog) {\n      throw new Error(\"Item with the given id was not registered: \".concat(itemId, \".\"));\n    }\n    return watchdog;\n  }\n  /**\n   * Checks whether an error comes from the context instance and not from the item instances.\n   *\n   * @internal\n   */\n  _isErrorComingFromThisItem(error) {\n    for (const watchdog of this._watchdogs.values()) {\n      if (watchdog._isErrorComingFromThisItem(error)) {\n        return false;\n      }\n    }\n    return areConnectedThroughProperties(this._context, error.context);\n  }\n}\n/**\n * Manager of action queues that allows queuing async functions.\n */\nclass ActionQueues {\n  constructor() {\n    this._onEmptyCallbacks = [];\n    this._queues = new Map();\n    this._activeActions = 0;\n  }\n  /**\n   * Used to register callbacks that will be run when the queue becomes empty.\n   *\n   * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\n   */\n  onEmpty(onEmptyCallback) {\n    this._onEmptyCallbacks.push(onEmptyCallback);\n  }\n  /**\n   * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\n   *\n   * @param queueId The action queue ID.\n   * @param action A function that should be enqueued.\n   */\n  enqueue(queueId, action) {\n    const isMainAction = queueId === mainQueueId;\n    this._activeActions++;\n    if (!this._queues.get(queueId)) {\n      this._queues.set(queueId, Promise.resolve());\n    }\n    // List all sources of actions that the current action needs to await for.\n    // For the main action wait for all other actions.\n    // For the item action wait only for the item queue and the main queue.\n    const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n    const queueWithAction = awaitedActions.then(action);\n    // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n    const nonErrorQueue = queueWithAction.catch(() => {});\n    this._queues.set(queueId, nonErrorQueue);\n    return queueWithAction.finally(() => {\n      this._activeActions--;\n      if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n        this._onEmptyCallbacks.forEach(cb => cb());\n      }\n    });\n  }\n}\n/**\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\n *\n * @param elementOrArray The value to transform to an array.\n * @returns An array created from data.\n */\nfunction toArray(elementOrArray) {\n  return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}","map":{"version":3,"names":["Watchdog","EditorWatchdog","areConnectedThroughProperties","getSubNodes","mainQueueId","Symbol","ContextWatchdog","constructor","Context","watchdogConfig","arguments","length","undefined","_watchdogs","Map","_context","_contextProps","Set","_actionQueues","ActionQueues","_watchdogConfig","_creator","contextConfig","create","_destructor","context","destroy","onEmpty","state","_fire","setCreator","creator","setDestructor","destructor","enqueue","_contextConfig","_create","getItem","itemId","watchdog","_getWatchdog","_item","getItemState","add","itemConfigurationOrItemConfigurations","itemConfigurations","toArray","Promise","all","map","item","id","Error","has","concat","type","_setExcludedProperties","set","on","evt","_ref","error","causesRestart","res","rethrowRestartEventOnce","off","sourceElementOrData","config","remove","itemIdOrItemIds","itemIds","delete","_destroy","_restart","catch","err","console","then","resolve","_startErrorHandling","Array","from","values","_stopErrorHandling","get","_isErrorComingFromThisItem","_onEmptyCallbacks","_queues","_activeActions","onEmptyCallback","push","queueId","action","isMainAction","awaitedActions","queueWithAction","nonErrorQueue","finally","forEach","cb","elementOrArray","isArray"],"sources":["D:/My Work/DubaiMusic/dubai-music/node_modules/@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Watchdog from './watchdog.js';\nimport EditorWatchdog from './editorwatchdog.js';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties.js';\nimport getSubNodes from './utils/getsubnodes.js';\nconst mainQueueId = Symbol('MainQueueId');\n/**\n * A watchdog for the {@link module:core/context~Context} class.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class ContextWatchdog extends Watchdog {\n    /**\n     * The context watchdog class constructor.\n     *\n     * ```ts\n     * const watchdog = new ContextWatchdog( Context );\n     *\n     * await watchdog.create( contextConfiguration );\n     *\n     * await watchdog.add( item );\n     * ```\n     *\n     * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\n     *\n     * @param Context The {@link module:core/context~Context} class.\n     * @param watchdogConfig The watchdog configuration.\n     */\n    constructor(Context, watchdogConfig = {}) {\n        super(watchdogConfig);\n        /**\n         * A map of internal watchdogs for added items.\n         */\n        this._watchdogs = new Map();\n        /**\n         * The current context instance.\n         */\n        this._context = null;\n        /**\n         * Context properties (nodes/references) that are gathered during the initial context creation\n         * and are used to distinguish the origin of an error.\n         */\n        this._contextProps = new Set();\n        /**\n         * An action queue, which is used to handle async functions queuing.\n         */\n        this._actionQueues = new ActionQueues();\n        this._watchdogConfig = watchdogConfig;\n        // Default creator and destructor.\n        this._creator = contextConfig => Context.create(contextConfig);\n        this._destructor = context => context.destroy();\n        this._actionQueues.onEmpty(() => {\n            if (this.state === 'initializing') {\n                this.state = 'ready';\n                this._fire('stateChange');\n            }\n        });\n    }\n    /**\n     * Sets the function that is responsible for the context creation.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setCreator( config => Context.create( config ) );\n     * ```\n     */\n    setCreator(creator) {\n        this._creator = creator;\n    }\n    /**\n     * Sets the function that is responsible for the context destruction.\n     * Overrides the default destruction function, which destroys only the context instance.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setDestructor( context => {\n     * \t// Do something before the context is destroyed.\n     *\n     * \treturn context\n     * \t\t.destroy()\n     * \t\t.then( () => {\n     * \t\t\t// Do something after the context is destroyed.\n     * \t\t} );\n     * } );\n     * ```\n     */\n    setDestructor(destructor) {\n        this._destructor = destructor;\n    }\n    /**\n     * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\n     * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\n     */\n    get context() {\n        return this._context;\n    }\n    /**\n     * Initializes the context watchdog. Once it is created, the watchdog takes care about\n     * recreating the context and the provided items, and starts the error handling mechanism.\n     *\n     * ```ts\n     * await watchdog.create( {\n     * \tplugins: []\n     * } );\n     * ```\n     *\n     * @param contextConfig The context configuration. See {@link module:core/context~Context}.\n     */\n    create(contextConfig = {}) {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this._contextConfig = contextConfig;\n            return this._create();\n        });\n    }\n    /**\n     * Returns an item instance with the given `itemId`.\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * @param itemId The item ID.\n     * @returns The item instance or `undefined` if an item with a given ID has not been found.\n     */\n    getItem(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog._item;\n    }\n    /**\n     * Gets the state of the given item. See {@link #state} for a list of available states.\n     *\n     * ```ts\n     * const editor1State = watchdog.getItemState( 'editor1' );\n     * ```\n     *\n     * @param itemId Item ID.\n     * @returns The state of the item.\n     */\n    getItemState(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog.state;\n    }\n    /**\n     * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\n     *\n     * Items can be passed together as an array of objects:\n     *\n     * ```ts\n     * await watchdog.add( [ {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * } ] );\n     * ```\n     *\n     * Or one by one as objects:\n     *\n     * ```ts\n     * await watchdog.add( {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * ] );\n     * ```\n     *\n     * Then an instance can be retrieved using the {@link #getItem} method:\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * Note that this method can be called multiple times, but for performance reasons it is better\n     * to pass all items together.\n     *\n     * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\n     */\n    add(itemConfigurationOrItemConfigurations) {\n        const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n        return Promise.all(itemConfigurations.map(item => {\n            return this._actionQueues.enqueue(item.id, () => {\n                if (this.state === 'destroyed') {\n                    throw new Error('Cannot add items to destroyed watchdog.');\n                }\n                if (!this._context) {\n                    throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n                }\n                let watchdog;\n                if (this._watchdogs.has(item.id)) {\n                    throw new Error(`Item with the given id is already added: '${item.id}'.`);\n                }\n                if (item.type === 'editor') {\n                    watchdog = new EditorWatchdog(null, this._watchdogConfig);\n                    watchdog.setCreator(item.creator);\n                    watchdog._setExcludedProperties(this._contextProps);\n                    if (item.destructor) {\n                        watchdog.setDestructor(item.destructor);\n                    }\n                    this._watchdogs.set(item.id, watchdog);\n                    // Enqueue the internal watchdog errors within the main queue.\n                    // And propagate the internal `error` events as `itemError` event.\n                    watchdog.on('error', (evt, { error, causesRestart }) => {\n                        this._fire('itemError', { itemId: item.id, error });\n                        // Do not enqueue the item restart action if the item will not restart.\n                        if (!causesRestart) {\n                            return;\n                        }\n                        this._actionQueues.enqueue(item.id, () => new Promise(res => {\n                            const rethrowRestartEventOnce = () => {\n                                watchdog.off('restart', rethrowRestartEventOnce);\n                                this._fire('itemRestart', { itemId: item.id });\n                                res();\n                            };\n                            watchdog.on('restart', rethrowRestartEventOnce);\n                        }));\n                    });\n                    return watchdog.create(item.sourceElementOrData, item.config, this._context);\n                }\n                else {\n                    throw new Error(`Not supported item type: '${item.type}'.`);\n                }\n            });\n        }));\n    }\n    /**\n     * Removes and destroys item(s) with given ID(s).\n     *\n     * ```ts\n     * await watchdog.remove( 'editor1' );\n     * ```\n     *\n     * Or\n     *\n     * ```ts\n     * await watchdog.remove( [ 'editor1', 'editor2' ] );\n     * ```\n     *\n     * @param itemIdOrItemIds Item ID or an array of item IDs.\n     */\n    remove(itemIdOrItemIds) {\n        const itemIds = toArray(itemIdOrItemIds);\n        return Promise.all(itemIds.map(itemId => {\n            return this._actionQueues.enqueue(itemId, () => {\n                const watchdog = this._getWatchdog(itemId);\n                this._watchdogs.delete(itemId);\n                return watchdog.destroy();\n            });\n        }));\n    }\n    /**\n     * Destroys the context watchdog and all added items.\n     * Once the context watchdog is destroyed, new items cannot be added.\n     *\n     * ```ts\n     * await watchdog.destroy();\n     * ```\n     */\n    destroy() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'destroyed';\n            this._fire('stateChange');\n            super.destroy();\n            return this._destroy();\n        });\n    }\n    /**\n     * Restarts the context watchdog.\n     */\n    _restart() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'initializing';\n            this._fire('stateChange');\n            return this._destroy()\n                .catch(err => {\n                console.error('An error happened during destroying the context or items.', err);\n            })\n                .then(() => this._create())\n                .then(() => this._fire('restart'));\n        });\n    }\n    /**\n     * Initializes the context watchdog.\n     */\n    _create() {\n        return Promise.resolve()\n            .then(() => {\n            this._startErrorHandling();\n            return this._creator(this._contextConfig);\n        })\n            .then(context => {\n            this._context = context;\n            this._contextProps = getSubNodes(this._context);\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => {\n                watchdog._setExcludedProperties(this._contextProps);\n                return watchdog.create(undefined, undefined, this._context);\n            }));\n        });\n    }\n    /**\n     * Destroys the context instance and all added items.\n     */\n    _destroy() {\n        return Promise.resolve()\n            .then(() => {\n            this._stopErrorHandling();\n            const context = this._context;\n            this._context = null;\n            this._contextProps = new Set();\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => watchdog.destroy()))\n                // Context destructor destroys each editor.\n                .then(() => this._destructor(context));\n        });\n    }\n    /**\n     * Returns the watchdog for a given item ID.\n     *\n     * @param itemId Item ID.\n     */\n    _getWatchdog(itemId) {\n        const watchdog = this._watchdogs.get(itemId);\n        if (!watchdog) {\n            throw new Error(`Item with the given id was not registered: ${itemId}.`);\n        }\n        return watchdog;\n    }\n    /**\n     * Checks whether an error comes from the context instance and not from the item instances.\n     *\n     * @internal\n     */\n    _isErrorComingFromThisItem(error) {\n        for (const watchdog of this._watchdogs.values()) {\n            if (watchdog._isErrorComingFromThisItem(error)) {\n                return false;\n            }\n        }\n        return areConnectedThroughProperties(this._context, error.context);\n    }\n}\n/**\n * Manager of action queues that allows queuing async functions.\n */\nclass ActionQueues {\n    constructor() {\n        this._onEmptyCallbacks = [];\n        this._queues = new Map();\n        this._activeActions = 0;\n    }\n    /**\n     * Used to register callbacks that will be run when the queue becomes empty.\n     *\n     * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\n     */\n    onEmpty(onEmptyCallback) {\n        this._onEmptyCallbacks.push(onEmptyCallback);\n    }\n    /**\n     * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\n     *\n     * @param queueId The action queue ID.\n     * @param action A function that should be enqueued.\n     */\n    enqueue(queueId, action) {\n        const isMainAction = queueId === mainQueueId;\n        this._activeActions++;\n        if (!this._queues.get(queueId)) {\n            this._queues.set(queueId, Promise.resolve());\n        }\n        // List all sources of actions that the current action needs to await for.\n        // For the main action wait for all other actions.\n        // For the item action wait only for the item queue and the main queue.\n        const awaitedActions = isMainAction ?\n            Promise.all(this._queues.values()) :\n            Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n        const queueWithAction = awaitedActions.then(action);\n        // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n        const nonErrorQueue = queueWithAction.catch(() => { });\n        this._queues.set(queueId, nonErrorQueue);\n        return queueWithAction.finally(() => {\n            this._activeActions--;\n            if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n                this._onEmptyCallbacks.forEach(cb => cb());\n            }\n        });\n    }\n}\n/**\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\n *\n * @param elementOrArray The value to transform to an array.\n * @returns An array created from data.\n */\nfunction toArray(elementOrArray) {\n    return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,eAAe;AACpC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,6BAA6B,MAAM,0CAA0C;AACpF,OAAOC,WAAW,MAAM,wBAAwB;AAChD,MAAMC,WAAW,GAAGC,MAAM,CAAC,aAAa,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,eAAe,SAASN,QAAQ,CAAC;EAClD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,WAAWA,CAACC,OAAO,EAAuB;IAAA,IAArBC,cAAc,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACpC,KAAK,CAACD,cAAc,CAAC;IACrB;AACR;AACA;IACQ,IAAI,CAACI,UAAU,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC3B;AACR;AACA;IACQ,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB;AACR;AACA;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC9B;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,IAAIC,YAAY,CAAC,CAAC;IACvC,IAAI,CAACC,eAAe,GAAGX,cAAc;IACrC;IACA,IAAI,CAACY,QAAQ,GAAGC,aAAa,IAAId,OAAO,CAACe,MAAM,CAACD,aAAa,CAAC;IAC9D,IAAI,CAACE,WAAW,GAAGC,OAAO,IAAIA,OAAO,CAACC,OAAO,CAAC,CAAC;IAC/C,IAAI,CAACR,aAAa,CAACS,OAAO,CAAC,MAAM;MAC7B,IAAI,IAAI,CAACC,KAAK,KAAK,cAAc,EAAE;QAC/B,IAAI,CAACA,KAAK,GAAG,OAAO;QACpB,IAAI,CAACC,KAAK,CAAC,aAAa,CAAC;MAC7B;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,UAAUA,CAACC,OAAO,EAAE;IAChB,IAAI,CAACV,QAAQ,GAAGU,OAAO;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAaA,CAACC,UAAU,EAAE;IACtB,IAAI,CAACT,WAAW,GAAGS,UAAU;EACjC;EACA;AACJ;AACA;AACA;EACI,IAAIR,OAAOA,CAAA,EAAG;IACV,OAAO,IAAI,CAACV,QAAQ;EACxB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,MAAMA,CAAA,EAAqB;IAAA,IAApBD,aAAa,GAAAZ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACrB,OAAO,IAAI,CAACQ,aAAa,CAACgB,OAAO,CAAC9B,WAAW,EAAE,MAAM;MACjD,IAAI,CAAC+B,cAAc,GAAGb,aAAa;MACnC,OAAO,IAAI,CAACc,OAAO,CAAC,CAAC;IACzB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,OAAOA,CAACC,MAAM,EAAE;IACZ,MAAMC,QAAQ,GAAG,IAAI,CAACC,YAAY,CAACF,MAAM,CAAC;IAC1C,OAAOC,QAAQ,CAACE,KAAK;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAYA,CAACJ,MAAM,EAAE;IACjB,MAAMC,QAAQ,GAAG,IAAI,CAACC,YAAY,CAACF,MAAM,CAAC;IAC1C,OAAOC,QAAQ,CAACX,KAAK;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIe,GAAGA,CAACC,qCAAqC,EAAE;IACvC,MAAMC,kBAAkB,GAAGC,OAAO,CAACF,qCAAqC,CAAC;IACzE,OAAOG,OAAO,CAACC,GAAG,CAACH,kBAAkB,CAAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}